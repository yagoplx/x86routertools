#!/usr/bin/env bash

#    x86routertools
#    Copyright (C) 2022 yavincl (yagocl@protonmail.ch)
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

###################################################################################
#    x86routertools script executable.                                            #
#    More information is available by running this script with '--help':          #
#    ./x86routertools --help                                                      #
#    This script should always exit with code 0 if run with '--version' or '-v'.  #
#                                                                                 #
#    What x86routertools aims to help fix:                                        #
#    https://www.bufferbloat.net/projects/make-wifi-fast/wiki/                    #
#    https://www.bufferbloat.net/projects/bloat/wiki/                             #
###################################################################################

trap_ctl(){
    # Clean up our trash and quit if the user does CTRL+C
    ledctl rmlock 1 &>/dev/null
    ledctl rmlock 2 &>/dev/null
    ledctl rmlock 3 &>/dev/null
    ledctl off &>/dev/null
    cleanup &>/dev/null
}

# Initialize trap
trap 'trap_ctl' SIGINT SIGTERM

# Initialize variables and language setting for compatibility
LANG=C
version="2.2.0"
error_count=0
crit_count=0
crit_add=0

# Set helpful aliases
alias _error=error
alias check_iface_exist=check_iface_exists

Version(){

    echo "x86routertools v$version"
    exit 0
}

Copyright(){

    echo "Copyright (C) 2022 yavincl"
    Version

}

# Descriptive help function
Help(){

    echo "Usage: x86routertools [options]"
    echo ""
    echo " {}: optional argument, *: only works with Atheros cards"
    echo "  @: add a 6 to the command for ipv6 (eg. ls -> ls6)"
    echo ""
    echo "  ROUTERTOOLS"
    echo "@ ls                         shows connected ipv4 devices"
    echo "@ all-addresses              shows assigned addresses"
    echo "  addresses [INTERFACE]      shows all addresses and routes assigned to interface"
    echo "  ports                      shows listening ports (TCP/UDP) on this machine"
    echo "  interfaces                 shows all interfaces on this machine"
    echo "@ routes                     shows routes on this machine"
    echo "  accesspoints               shows a list of all AP names in routertools"
    echo "  capabilities [AP] [MAC]    shows what capabilities the connected device has"
    echo "  status-internet            checks if internet access is present and exits"
    echo "  status-wifi                checks if the wifi AP(s) is/are up and running and exits"
    echo "  status-services            checks if important services are running and exits"
    echo "  status                     shows a shortened version of all statuses"
    echo "  info-internet              shows information about the default route (internet)"
    echo "  info-wifi {AP}             shows information about the wifi APs"
    echo "  info-services              shows all important services status verbosely"
    echo "  info-qdisc                 shows all configured queue disciplines"
    echo "  info                       shows a shortened version of all information commands"
    echo "  display-rates [AP] [MAC]   displays what data rates a device is using to communicate with the router, 100ms resolution"
    echo "* display-airtime [AP] [MAC] displays airtime usage for a given device, 100ms resolution"
    echo "* display-ani [AP]           displays runtime info about Adaptive Noise Immunity, 100ms resolution"
    echo "  display-stats [AP] [MAC]   displays wireless link with device stats"
    echo "  display-local-network      displays all connected devices to this machine (ARP), 1s resolution"
    echo "  display-qdisc [INTERFACE]  displays queue discipline statistics for the given interface, 100ms resolution"
    echo "  display-interfaces         displays interface stats via netstat, 100ms resolution"
    echo "  try-resolve [DOMAIN]       checks if domain name is resolvable"
    echo "  try-reach [ADDRESS]        checks if domain/address is reachable via ping"
    echo "  reset-config               resets x86routertools configuration files to default"
    echo ""
    echo "  CHECKS"
    echo "  check-internet             checks and runs start-internet if connection unavailable, also checks DNS"
    echo "  check-wifi {AP}            checks and restarts the wifi AP(s) if not started"
    echo "  check                      checks both (all) wifi APs and internet, starts them automatically"
    echo ""
    echo "  ACTIONS"
    echo "  start-internet             runs the start-internet script"
    echo "  stop-internet              runs the stop-internet script"
    echo "  start-services             starts inactive important services"
    echo "  start-wifi {AP}            starts selected AP or all APs"
    echo "  stop-wifi {AP}             stops selected AP or all APs"
    echo "  restart-services           restarts important services"
    echo "  restart-wifi {AP}          restarts the selected AP or all APs"
    echo "  restart-internet           restarts the internet connection via the user defined scripts"
    echo "  sysctl-install             installs optimized options to /etc/sysctl.d and reloads sysctl"
    echo ""
    echo "  TOGGLES"
    echo "  qdisc                      apply routertools's per-category queue disciplines"
    echo "  qdisc-off                  "
    echo "* paprd-on {AP}              controls digital predistortion"
    echo "* paprd-off {AP}             "
    echo "  dynack-on {AP}             controls ack timeout estimation"
    echo "  dynack-off {AP}            "
    echo "* ani-on {AP}                controls adaptive noise immunity"
    echo "* ani-off {AP}               "
    echo "* lnamix-on {AP}             controls low noise amplifier"
    echo "* lnamix-off {AP}            "
    echo "* ath9k-recalibrate {AP}     turns toggled special features off and then back on"
    echo "  frame-opt-on {AP}          controls custom framesize optimization"
    echo "  frame-opt-off {AP}         "
    echo "  powersave-on {AP}          controls power saving features"
    echo "  powersave-off {AP}         "
    echo ""
    echo "  ROUTERTOOLS DAEMON"
    echo "  --daemon [AP]              controls the watchdog daemon for the selected AP."
    echo "  --daemon-stop [AP]         "
    echo "  --daemon-inet              controls the watchdog daemon for the internet interface."
    echo "  --daemon-stop-inet         "
    echo "  --daemon-reload            reloads configuration for active daemons without restarting them"
    echo "  --list-daemons             lists active daemons and PIDs"
    echo ""
    echo "  OPTIONS"
    echo "  -q, --quiet                silence some dialog"
    echo "  -V, --verbose              operate verbosely"
    echo "  -C, --noclear              never clear the screen"
    echo "  -D, --detach               with, --daemon or --daemon-inet run as detached processes."
    echo "  -Z, --disown               always disown all jobs"
    echo "  -h, --help                 show help and quit"
    echo "  -v, --version              show version and quit"

}

# Short help function
Invalid_Help(){

    if [[ $count_arg -eq 1 ]]; then
        Help
        echo
        ifnq echo "x86routertools: Invalid command line option $cmd_arg"
        exit 1
    elif [[ $count_arg -gt 1 ]]; then
        ifnq echo "x86routertools: Invalid command line option $cmd_arg"
        ifnq echo "Run 'x86routertools -h' for help."
        exit 1
    fi


}

cleanup(){

    rm /dev/shm/routertools.netrec.inet 2>/dev/null
    rm /dev/shm/routertools.netrec.dns 2>/dev/null

    if [[ $quiet != 1 ]]; then
        _exit "x86routertools was terminated."
    else
        exit 0
    fi

}

error(){

    # Functions that can error should give their errors to _error functions
    if [[ $quiet != 1 ]]; then
        error_count=$(( $error_count + 1 ))
        echo "x86routertools error $error_suffix:" "$@" "In function: ${FUNCNAME[$((1 + $crit_add))]}"
        ifv echo "Call stack: ${FUNCNAME[*]}]"
    else
        error_count=$(( $error_count + 1 ))
    fi
    return $?

}

crit_error(){
    crit_count=$(( crit_count + 1 ))

    # Jump up on the call stack
    crit_add=1

    error_suffix="(FATAL)"
    error "$@"
    unset error_suffix

    crit_add=0

    if [[ "$nofail" != "1" ]]; then
        _exit
    fi

}

# ifv runs a command only if we are in verbose mode
ifv(){
    [[ $verbose = "1" ]] && "$@"
    return $?
}

# ifnq runs a command only if we are not in quiet mode
ifnq(){
    [[ $quiet = "1" ]] || "$@"
    return $?
}

getphy(){
    # Takes a wifi device and spits out its sanitized PHY number
    phy=$(iw dev "$i" info | grep -i "wiphy" | tr -d "wiphy[:blank:]" | cut -c 1)

    if [[ "$phy" == "" ]]; then
        return 1
    else
        return 0
    fi

}

initfile(){

    # Initializes config files as sourceable bash scripts
    for i_file in $@; do
        ifv echo "Initialized file $i_file"
        echo "#!/usr/bin/env bash" > $i_file
    done

    unset i_file

}

checksu(){

    # Checks if we are root
    if [[ ! "$EUID" -eq 0 ]]; then
        return 1
    else
        return 0
    fi

}

rootnotify(){

    # Global notifications function
    # Notifies X11 users via notify-send
    if [[ "$notify_mode" == "x11" ]] || [[ "$notify_mode" == "both" ]]; then
        local display=":$(ls /tmp/.X11-unix/* | sed 's#/tmp/.X11-unix/X##' | head -n 1)"
        local user=$(who | grep '('$display')' | awk '{print $1}' | head -n 1)
        local uid=$(id -u $user)
        # Push notification
        sudo -u $user DISPLAY=$display DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$uid/bus notify-send -a x86routertools "$@"
    fi

    # Notifies TTY users via wall
    if [[ "$notify_mode" == "tty" ]] || [[ "$notify_mode" == "both" ]]; then
        wall -n "$@"
    fi

    ifnq echo "Sent notification to user $user"
    # Always return 0
    return 0
}

resetcfg(){

    # Resets all configuration in /etc/routertools.d
    checksu || crit_error "You must be root to execute this function."

    if [[ -d /etc/routertools.d ]]; then
        echo "This will delete EVERYTHING under /etc/routertools.d"
        echo "Are you sure you want to do this?"
        echo "[Enter-> Continue] [Ctrl+C-> Cancel]"

        # "enter" detection
        read x
        unset x

        rm -r /etc/routertools.d
    fi

    echo "Initializing configuration..."
    initfs
    initfs_daemon_cfg
    return $?
}

initfs(){

    # Initialize folders and populate config files

    if [[ $DUMP_INITFS -eq 1 ]]; then
        PREFIX=""
    else
        checksu || crit_error "Cannot create configuration, please try again as root."
        PREFIX="/etc/"
    fi

    if [[ ! -d /dev/shm/x86routertools ]]; then
        mkdir /dev/shm/x86routertools &>/dev/null
    fi

    if [[ ! -d ${PREFIX}routertools.d ]]; then
        echo "Populating ${PREFIX}routertools.d..."
        mkdir ${PREFIX}routertools.d || crit_error
        ifv echo "Creating basic directory structure in ${PREFIX}routertools.d"
        mkdir ${PREFIX}routertools.d/wifi-access-points
        mkdir ${PREFIX}routertools.d/scripts

        initfile ${PREFIX}routertools.d/scripts/stop-internet
        initfile ${PREFIX}routertools.d/scripts/start-internet
        initfile ${PREFIX}routertools.d/scripts/start-example_interface
        initfile ${PREFIX}routertools.d/scripts/stop-example_interface
        initfile ${PREFIX}routertools.d/x86routertools.conf
        initfile ${PREFIX}routertools.d/wifi-access-points/example_interface.conf

        ifv echo "Setting permissions on ${PREFIX}routertools.d"
        chmod ugo+x ${PREFIX}routertools.d
        chmod go-x ${PREFIX}routertools.d/scripts
        chmod go-x ${PREFIX}routertools.d/wifi-access-points
        chmod go+r ${PREFIX}routertools.d/x86routertools.conf


        echo "I am now going to download the most recent example configuration file for hostapd."
        echo "Please press ENTER to continue."
        read x
        unset x
        echo "Downloading example hostapd.conf from w1.fi. Please wait..."
        wget -q https://w1.fi/cgit/hostap/plain/hostapd/hostapd.conf -O ${PREFIX}routertools.d/wifi-access-points/example_interface_hostapd.conf || error "Couldn't download example."

        # Populate files
        initfile ${PREFIX}routertools.d/scripts/start-internet
        initfile ${PREFIX}routertools.d/scripts/stop-internet
        # Contents of config files
        d="${PREFIX}routertools.d"
        f="$d/scripts/start-internet"
        echo "# This script is run with start-internet and alike commands" >> $f
        echo "# Example: pppoe-start on Arch Linux with a PPPoE modem." >> $f
        echo "pppoe-start" >> $f

        f="$d/scripts/stop-internet"
        echo "# This script is run with stop-internet and alike commands" >> $f
        echo "# Example: pppoe-stop on Arch Linux with a PPPoE modem." >> $f
        echo "pppoe-stop" >> $f

        f="$d/scripts/stop-example_interface"
        echo "# This script is run with stop-wifi and alike commands" >> $f
        echo "" >> $f

        f="$d/scripts/start-example_interface"
        echo "# This script is run with start-wifi and alike commands" >> $f
        echo "" >> $f

        f="$d/x86routertools.conf"
        echo "# x86routertools main configuration file" >> $f
        echo "" >> $f
        echo "# use_logger -> a boolean." >> $f
        echo "# if true, the script will try to use logger to send messages to the system log." >> $f
        echo "# if you are running routertools in the crontab or via a systemd service, you don't need this." >> $f
        echo "use_logger=false" >> $f
        echo "" >> $f
        echo "# status_led -> a string. point this to an entry in /sys/class/leds/ to have routertools control that led" >> $f
        echo "# for indicating status changes. leave empty to turn it off." >> $f
        echo "status_led=ath9k-phy0" >> $f
        echo "" >> $f
        echo "# inet_iface -> the interface that will be checked by" >> $f
        echo "# internet commands, and started by internet scripts. example: enp2s0" >> $f
        echo "inet_iface=ppp0" >> $f
        echo "" >> $f
        echo "# dns_check_addresses -> an array." >> $f
        echo "# can contain up to 4 names to try & resolve on internet tests. example: google.com" >> $f
        echo "# if unset, will use defaults." >> $f
        echo "dns_check_addresses=()" >> $f
        echo "" >> $f
        echo "# ip_check_addresses -> an array." >> $f
        echo "# can contain up to 2 IPs to ping on internet tests. example: 8.8.8.8" >> $f
        echo "# if unset, will use defaults." >> $f
        echo "ip_check_addresses=()" >> $f
        echo "" >> $f
        echo "# important_services -> a list of systemd services important to this router." >> $f
        echo "# they will be started by the connectivity commands. example: dnsmasq haveged" >> $f
        echo "# you should also include your firewall service here." >> $f
        echo "important_services=dnsmasq" >> $f
        echo "" >> $f
        echo "# query_log_file -> a path to a file to be watched by display-queries, your resolver log for example" >> $f
        echo "query_log_file=" >> $f
        echo "" >> $f
        echo "# regenerate_link_local -> a boolean. regenerates IPv6 link local addresses when a new interface is brought up" >> $f
        echo "regenerate_link_local=true" >> $f
        echo "" >> $f
        echo "# notify_mode -> if properly set, check commands like check-inet will send a global notification if they notice" >> $f
        echo "# something is wrong. can be 'x11' for a desktop notification, 'tty' for terminal, and 'both' for both. Use 'none' if you don't want this." >> $f
        echo "notify_mode=none" >> $f
        echo "" >> $f
        echo "# inet_check_timeout -> a number in seconds. this is for how long it'll wait for an external address to respond" >> $f
        echo "# or for dns names to be resolved." >> $f
        echo "inet_check_timeout=6" >> $f
        echo "" >> $f
        echo "# silence_check_services -> a boolean. if true, you won't get a warning about things not being installed. " >> $f
        echo "silence_check_services=false" >> $f
        echo "" >> $f
        echo "# enable_rngd -> a boolean. if true, rng-tools' rngd will be started along with the wifi AP and haveged." >> $f
        echo "# it makes additional randomness for the OS. however, it may cause high CPU usage on computers without hardware RNG generators." >> $f
        echo "enable_rngd=false" >> $f
        echo "" >> $f
        echo "# enable_cake_sqm -> a boolean. if true, CAKE queue discipline will be applied to interfaces" >> $f
        echo "# in a way similar to sqm_scripts. This helps with bufferbloat." >> $f
        echo "enable_cake_sqm=true" >> $f
        echo "" >> $f
        echo "# enable_cake_ack_filter -> a boolean. if true, CAKE ack filtering will be enabled on suitable interfaces." >> $f
        echo "enable_cake_ack_filter=false" >> $f
        echo "" >> $f
        echo "# sqm_ack_filter_aggressive -> a boolean. if true, and enable_cake_ack_filter is also true, the ack filter" >> $f
        echo "# will be set to aggressive mode on all interfaces." >> $f
        echo "sqm_ack_filter_aggressive=false" >> $f
        echo "" >> $f
        echo "# restart_services_for_wifi -> a boolean. if true, important_services will be automatically restarted alongside wifi interfaces." >> $f
        echo "restart_services_for_wifi=false" >> $f
        echo "" >> $f
        echo "# sqm_inet_upload -> a number. set this to your internet's upload speed in megabit per second." >> $f
        echo "# if this is not set, i will just not do upload traffic shaping." >> $f
        echo "sqm_inet_upload=" >> $f
        echo "" >> $f
        echo "# sqm_inet_download -> a number. set this to your internet's download speed in megabit per second." >> $f
        echo "# if this is not set, i will just not do download traffic shaping." >> $f
        echo "sqm_inet_download=" >> $f
        echo "" >> $f
        echo "# sqm_wash_markings -> a boolean. if true, washes out traffic type markings inbound." >> $f
        echo "sqm_wash_markings=false" >> $f
        echo "" >> $f
        echo "# sqm_use_overheads -> a boolean. if true, sqm will use some predefined overhead keywords for packet size compensation." >> $f
        echo "sqm_use_overheads=true" >> $f
        echo "" >> $f
        echo "# sqm_diffserv -> a number. select number of diffserv tins cake will use, can be 0, 3, 4 or 8" >> $f
        echo "# 0 is besteffort and may complement sqm_wash_markings. if unset, 4 will be used." >> $f
        echo "sqm_diffserv=4" >> $f
        echo "" >> $f
        echo "# sqm_enable_ifb_on_ethernet -> a boolean. if true, full cake traffic shaping" >> $f
        echo "# will also be attempted on ethernet interfaces, not just ppp." >> $f
        echo "# enable this if you get internet on this machine via NAT/DHCP from another router." >> $f
        echo "sqm_enable_ifb_on_ethernet=false" >> $f
        echo "" >> $f
        echo "# enable_bbr -> a boolean. if true, enables Google's BBR tcp congestion algorithm for" >> $f
        echo "# enhanced network performance, when applying SQM. Will enable BBRv2 instead of v1 if available." >> $f
        echo "enable_bbr=true" >> $f
        echo "" >> $f
        echo "# enable_rpfilter -> a boolean. if true, enables reverse path filtering on all interfaces, when applying qdisc options." >> $f
        echo "# this will block common address forging attacks on your network." >> $f
        echo "# it does not replace a firewall!" >> $f
        echo "enable_rpfilter=true" >> $f

        f="$d/wifi-access-points/example_interface.conf"
        echo "# x86routertools interface configuration file" >> $f
        echo "# This file can be reset to the original via 'routertools reset-config'" >> $f
        echo "# To change what interface this file belongs to just rename it to 'whatever_interface_name.conf'" >> $f
        echo "# Same goes for the hostapd configuration file except the filename should end with _hostapd.conf" >> $f
        echo "" >> $f
        echo "# WIRELESS INTERFACE OPTIONS #" >> $f
        echo "# Check https://wiki.dd-wrt.com/wiki/index.php/Atheros/ath_wireless_settings for explanations." >> $f
        echo "" >> $f
        echo "# hostapd_wait_for_secs -> seconds to wait for hostapd to be done. 'auto' tries to automatically detect." >> $f
        echo "hostapd_wait_for_secs=auto" >> $f
        echo "" >> $f
        echo "# wifi_txpower -> transmission power for this interface" >> $f
        echo "# can be 'auto' or a number in dBm for fixed power. Auto is usually best." >> $f
        echo "wifi_txpower=auto" >> $f
        echo "" >> $f
        echo "# wifi_powersave -> a boolean (true/false). if true, powersaving features will be enabled as soon as the AP is turned on." >> $f
        echo "wifi_powersave=false" >> $f
        echo "" >> $f
        echo "# wifi_regdomain -> if set to a two-letter country code like GY, will set this as the system's regulatory domain" >> $f
        echo "wifi_regdomain=GY" >> $f
        echo "" >> $f
        echo "# wifi_drivers -> a list of kernel modules to remove and insert upon starting this AP." >> $f
        echo "# this is not the same as hostapd's driver configuration. lspci -v may give you the name of the kernel module the interface is using." >> $f
        echo "# leave commented if you don't know." >> $f
        echo "# wifi_drivers= " >> $f
        echo "" >> $f
        echo "# wifi_reload_drivers -> a boolean (true/false). if true, the drivers will be reloaded on AP start." >> $f
        echo "# depends on wifi_drivers, and fixes some issues with some drivers such as rtl8192eX" >> $f
        echo "# wifi_reload_drivers=false" >> $f
        echo "" >> $f
        echo "# wifi_darkstat_port -> a port. if set, darkstat will be initialized on this interface and port" >> $f
        echo "# so that you may snoop on its traffic statistics via a web browser. Requires darkstat to be installed" >> $f
        echo "# wifi_darkstat_port=667" >> $f
        echo "" >> $f
        echo "# wifi_virtual_interfaces -> a list of additional interfaces you spawned with hostapd bssids." >> $f
        echo "# the script needs to know about them to properly initialize them." >> $f
        echo "# if you are only using one AP on this network card you need not set this." >> $f
        echo "# wifi_virtual_interfaces=" >> $f
        echo "" >> $f
        echo "# wifi_dynack -> a boolean. true enables dynamic ack timeout estimation algorithm, only works on ath9k cards" >> $f
        echo "wifi_dynack=false" >> $f
        echo "" >> $f
        echo "# wifi_paprd -> a boolean. true enables digital predistortion, only works on Atheros cards." >> $f
        echo "wifi_paprd=true" >> $f
        echo "" >> $f
        echo "# wifi_retry_short -> a number. sets the limit of times the AP will retry sending a packet before dropping it." >> $f
        echo "# default is 4" >> $f
        echo "wifi_retry_short=4" >> $f
        echo "" >> $f
        echo "# wifi_retry_long -> a number. sets the limit of times the AP will retry sending a packet before dropping it in RTS/CTS mode." >> $f
        echo "# default is 3" >> $f
        echo "wifi_retry_long=3" >> $f
        echo "" >> $f
        echo "# wifi_frame_optimization -> a boolean. enables custom frame size optimization." >> $f
        echo "# overrides retries, fragmentation, and MTU related options. " >> $f
        echo "wifi_frame_optimization=true" >> $f
        echo "" >> $f
        echo "# wifi_lnamix -> a boolean. true enables low noise amplifier mixing, only works on Atheros cards." >> $f
        echo "wifi_lnamix=true" >> $f
        echo "" >> $f
        echo "# wifi_ani -> a boolean. false disables adaptive noise immunity, only works on Atheros cards." >> $f
        echo "wifi_ani=false" >> $f
        echo "" >> $f
        echo "# wifi_coverage -> a number. sets coverage class in microsec of air propagation time. default is unset." >> $f
        echo "wifi_coverage=" >> $f
        echo "" >> $f
        echo "# wifi_distance -> a number. sets maximum ack timeout by distance in meters. default is unset. setting this disables dynack." >> $f
        echo "wifi_distance=" >> $f
        echo "" >> $f
        echo "" >> $f
        echo "# NETWORKING OPTIONS #" >> $f
        echo "" >> $f
        echo "# require_internet -> a boolean. true makes it so this wireless interface will only be set up via check commands if an internet connection is available." >> $f
        echo "require_internet=false" >> $f
        echo "" >> $f
        echo "# enable_ipv6 -> a boolean. true only enables ipv6 forwarding on this interface." >> $f
        echo "# if you actually want it to work you need radvd or a configured dnsmasq." >> $f
        echo "# and manual address addition/routing via scripting." >> $f
        echo "enable_ipv6=true" >> $f
        echo "" >> $f
        echo "# enable_pptp -> a boolean. true inserts the module needed for PPTP. if you are not sure you need it say false here, as the Point to Point Tunneling Protocol is known to be insecure." >> $f
        echo "enable_pptp=false" >> $f
        echo "" >> $f
        echo "# gateway -> a gateway in ipv4 format. example: 192.168.1.1" >> $f
        echo "# usually this is the internet router's private ip address." >> $f
        echo "# since this computer is probably also the internet providing router," >> $f
        echo "# you may want to set it to this computer's ip address as set in /etc/hosts" >> $f
        echo "# this will also be used as the interface's ipv4 address." >> $f
        echo "# gateways for more virtual interfaces can be set in gateway_x" >> $f
        echo "gateway=192.168.1.1" >> $f
        echo "gateway_x='192.168.2.1 192.168.3.1'" >> $f
        echo "" >> $f

        unset f
        unset d
    fi
}

initfs_daemon_cfg(){

    if [[ $DUMP_INITFS -eq 1 ]]; then
        mkdir routertools.d 2>/dev/null
        initfile routertools.d/daemon.conf
        chmod og+xr routertools.d/daemon.conf
        f=routertools.d/daemon.conf
    else
        checksu || crit_error "Cannot create configuration, please try again as root."
        mkdir /etc/routertools.d 2>/dev/null
        initfile /etc/routertools.d/daemon.conf
        chmod og+xr /etc/routertools.d/daemon.conf
        f=/etc/routertools.d/daemon.conf
    fi

    echo "# x86routertools daemon mode configuration file" >> $f
    echo "# these options are only valid for the --daemon command" >> $f
    echo "" >> $f
    echo "# daemon_manage_inet_every -> a number in seconds. the internet watchdog will be executed every this amount of time." >> $f
    echo "daemon_manage_inet_every=30" >> $f
    echo "" >> $f
    echo "# daemon_manage_wifi_every -> a number in seconds. the wifi watchdog will be executed every this amount of time." >> $f
    echo "daemon_manage_wifi_every=40" >> $f
    echo "" >> $f
    echo "# daemon_wifi_wait_for_internet_timeout -> a number in seconds." >> $f
    echo "# if running in daemon mode and require_internet is enabled, after this long and internet is still not available wifi will be started anyway." >> $f
    echo "# set to 0 if you really want to disable this" >> $f
    echo "daemon_wifi_wait_for_internet_timeout=120" >> $f
    echo "" >> $f
    echo "# daemon_ath9k_recalibrate_every -> a number in seconds." >> $f
    echo "# if running the wifi daemon and wifi_driver for that interface includes ath9k, ath9k-recalibrate will be run every X seconds." >> $f
    echo "# recommended is hourly (3600). Set to 0 to disable." >> $f
    echo "daemon_ath9k_recalibrate_every=0" >> $f
    echo "" >> $f

    unset f
}

genconfig(){
    # Dump configuration 'presets' into current folder
    export nofail=1
    DUMP_INITFS=1 initfs
    DUMP_INITFS=1 initfs_daemon_cfg
}

ledctl(){

    if [[ ! -d "/sys/class/leds/$status_led" ]]; then
        return 0
    fi

    control="/sys/class/leds/$status_led"
    mkdir -p /dev/shm/routertools_locks &>/dev/null

    case $1 in

        periodic)
            [[ $(ls /dev/shm/routertools_locks/ | grep -c 'x86routertools_led_lock') -ne 0 ]] && return 0
            echo timer | tee $control/trigger &>/dev/null

            # Potential race condition with blink
            if [[ ! -f "$control"/shot ]]; then
                echo 500 | tee $control/delay_on &>/dev/null
                echo 500 | tee $control/delay_off &>/dev/null
            fi
            ;;

        blink)
            [[ $(ls /dev/shm/routertools_locks/ | grep -c 'x86routertools_led_lock') -ne 0 ]] && return 0

            if [[ ! -f "$control"/shot ]]; then
                echo oneshot | tee $control/trigger &>/dev/null
                echo 100 | tee $control/delay_on &>/dev/null
                echo 100 | tee $control/delay_off &>/dev/null
            else
                echo 1 | tee $control/shot &>/dev/null
            fi
            ;;

        mklock)
            touch /dev/shm/routertools_locks/x86routertools_led_lock_$2 &>/dev/null
            ;;

        rmlock)
            rm /dev/shm/routertools_locks/x86routertools_led_lock_$2 &>/dev/null
            ;;

        on)
            [[ $(ls /dev/shm/routertools_locks/ | grep -c 'x86routertools_led_lock') -ne 0 ]] && return 0
            echo default-on | tee $control/trigger &>/dev/null
            ;;

        off)
            [[ $(ls /dev/shm/routertools_locks/ | grep -c 'x86routertools_led_lock') -ne 0 ]] && return 0
            echo none | tee $control/trigger &>/dev/null
            ;;
    esac

}

send_to_syslog(){

    [[ "$use_logger" == "false" ]] && return 0

    # Return 0 since this is optional
    command -v logger > /dev/null || return 0

    # Don't block thread on access to syslog
    logger "$@" &

}

# Checks if value is a valid boolean (script uses lowercase)
is_bool(){

    local value="$1"
    if [[ "$value" == "true" ]] || [[ "$value" == "false" ]]; then
        return 0
    else
        return 1
    fi

}

# Checks if value is a valid integer
is_int(){

    local value="$1"
    case ${value#[-+]} in
        *[!0-9]*) return 1 ;;
        '') ifv echo 'warning: ignoring unset variable'; return 0 ;;
        * ) return 0 ;;
    esac

}

# Checks if a given MAC address is valid (regex)
check_mac_valid(){

    local dmac="$1"

    if [[ "$dmac" =~ ^([a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2}$ ]]; then
        return 0
    else
        return 1
    fi

}

# Display a rapidly updating graph of Adaptive Noise Immunity stats for a given AP
display_ani(){

    checksu || crit_error "You must be root to use debugfs."
    local i="$1"
    check_iface_exists $i || crit_error "Interface $i is not available"
    getphy $i

    watch -n 0.1 cat /sys/kernel/debug/ieee80211/phy$phy/ath9k/ani

}

# Display a rapidly updating graph of queue discipline data for a given interface
display_qdisc(){

    local i="$1"
    watch -n .1 tc -s qdisc show dev $i

}

display_stats(){

    checksu || crit_error "You must be root to use debugfs."
    local device_mac="$2"
    local i="$1"
    check_iface_exists $i || crit_error "Interface $i is not available"
    getphy $i
    check_mac_valid $device_mac || crit_error "Invalid MAC address: $device_mac"

    watch -n 0.1 iw $i station get $device_mac
}

show_capabilities(){

    checksu || crit_error "You must be root to use debugfs."
    local device_mac="$2"
    local i="$1"
    check_iface_exists $i || crit_error "Interface $i is not available"
    getphy $i
    check_mac_valid $device_mac || crit_error "Invalid MAC address: $device_mac"
    echo "Device flags:"
    cat /sys/kernel/debug/ieee80211/phy$phy/netdev:$i/stations/$device_mac/flags
    echo ""
    echo "Capabilities:"
    cat /sys/kernel/debug/ieee80211/phy$phy/netdev:$i/stations/$device_mac/ht_capa
    cat /sys/kernel/debug/ieee80211/phy$phy/netdev:$i/stations/$device_mac/vht_capa
    cat /sys/kernel/debug/ieee80211/phy$phy/netdev:$i/stations/$device_mac/he_capa 

}
# Display a rapidly updating graph of data rate stats for a given MAC address and AP
display_rates(){

    checksu || crit_error "You must be root to use debugfs."
    local device_mac="$2"
    local i="$1"
    check_iface_exists $i || crit_error "Interface $i is not available"
    getphy $i
    check_mac_valid $device_mac || crit_error "Invalid MAC address: $device_mac"

    watch -n 0.1 cat /sys/kernel/debug/ieee80211/phy$phy/netdev:$i/stations/$device_mac/rc_stats

}

# Display a rapidly updating graph of airtime usage for a given MAC address and AP
display_airtime(){

    checksu || crit_error "You must be root to use debugfs."
    local device_mac="$2"
    local i="$1"
    check_iface_exists $i || crit_error "Interface $i is not available"
    getphy $i
    check_mac_valid $device_mac || crit_error "Invalid MAC address: $device_mac"

    watch -n 0.1 cat /sys/kernel/debug/ieee80211/phy$phy/netdev:$i/stations/$device_mac/airtime

}

# Display a rapidly updating graph of all connected devices to the local machine
display_local_network(){
    watch -n 1 arp -ev
}

# Show all connected devices
show_local_network(){
    arp -av
}

show_local_network_6(){
    ip -6 neigh
}

show_routes(){
    ip route
}

show_routes_6(){
    ip -6 route
}

show_interfaces(){
    netstat -i
}

show_ports(){
    netstat -tulpnW
}

show_all_addresses(){
    ip addr
}

show_all_addresses_6(){
    ip -6 addr
}

show_addresses(){
    local i="$1"
    [[ "$i" == "" ]] && crit_error "No argument given."
    check_iface_present "$i" || crit_error "The interface $i does not exist!"
    echo "IPv4 addresses on $i:"
    ip addr show $i | grep inet
    echo "IPv6 addresses on $i:"
    ip -6 addr show $i | grep inet6
}

display_interfaces(){
    watch -n 0.1 netstat -iWn
}

display_queries(){
    checksu || crit_error "You must be root to do this!"
    if [[ -f "$query_log_file" ]]; then
        watch -n 0.1 tail --lines=$((LINES - 4)) "$query_log_file"
    else
        crit_error "No queries log file is configured."
    fi
}

try_reach(){
    local i="$1"
    [[ "$i" == "" ]] && quiet=0 crit_error "No argument given."
    get_inet_status "$i"
    status=$?

    [[ $status -eq 0 ]] && echo "$i is reachable by ICMP echo packets."
    [[ $status -eq 0 ]] || echo "$i is NOT reachable by ICMP echo packets."
}

try_resolve(){
    local i="$1"
    [[ "$i" == "" ]] && quiet=0 crit_error "No argument given."
    get_dns_status "$i"
    status=$?

    [[ $status -eq 0 ]] && echo "$i could be resolved."
    [[ $status -eq 0 ]] || echo "$i could NOT be resolved."
}

# Disable (or attempt to) CCK rates so we don't take up massive amounts of airtime
# Probably doesn't work
disable_cck_rates(){

    checksu || crit_error "You must be root to toggle this."
    if [[ $@ == "" ]]; then
        wifi_ap_interfaces="$(get_wifi_iface_list)"
    else
        wifi_ap_interfaces="$@"
    fi

    for i in $wifi_ap_interfaces; do
        getphy $i

        echo "Disabling CCK rates on $i"
        iw $i set bitrates legacy-2.4 6 9 12 18 24 36 48 54 2>/dev/null || iw $i set bitrates legacy-2.4 1 2 5.5 11 2>/dev/null
    done

}

# Enable Adaptive Noise Immunity
ani_on(){

    checksu || crit_error "You must be root to toggle this."

    if [[ $@ == "" ]]; then
        wifi_ap_interfaces="$(get_wifi_iface_list)"
    else
        wifi_ap_interfaces="$@"
    fi

    for i in $wifi_ap_interfaces; do
        getphy $i

        echo "Enabling adaptive noise immunity on $i"
        echo 1 > /sys/kernel/debug/ieee80211/phy$phy/ath9k/ani 2>/dev/null || error "Failed to set parameter"
    done

}

# Disable Adaptive Noise Immunity
ani_off(){

    checksu || crit_error "You must be root to toggle this."

    if [[ $@ == "" ]]; then
        wifi_ap_interfaces="$(get_wifi_iface_list)"
    else
        wifi_ap_interfaces="$@"
    fi

    for i in $wifi_ap_interfaces; do
        getphy $i

        echo "Disabling adaptive noise immunity on $i"
        echo 0 > /sys/kernel/debug/ieee80211/phy$phy/ath9k/ani 2>/dev/null || error "Failed to set parameter"
    done

}

frame_opt_on(){

    checksu || crit_error "You must be root to toggle this."

    if [[ $@ == "" ]]; then
        wifi_ap_interfaces="$(get_wifi_iface_list)"
    else
        wifi_ap_interfaces="$@"
    fi

    for i in $wifi_ap_interfaces; do
        load_prefs_iface $i
        getphy $i

        echo "Enabling custom frame optimization on $i"
        iw phy$phy set frag 256
        ifconfig $i mtu 2304 || ifconfig $i mtu 1900
        iw phy$phy set rts off

        if [[ "$wifi_distance" != "" ]]; then
            iw phy$phy set distance "$wifi_distance"
        else
            iw phy$phy set distance 1
        fi

        if [[ "$wifi_dynack" == "true" ]]; then
            iw phy$phy set distance auto
        fi

    done

}

# Custom frame size optimization
frame_opt_off(){

    checksu || crit_error "You must be root to toggle this."

    if [[ $@ == "" ]]; then
        wifi_ap_interfaces="$(get_wifi_iface_list)"
    else
        wifi_ap_interfaces="$@"
    fi

    for i in $wifi_ap_interfaces; do
        load_prefs_iface $i
        getphy $i

        echo "Disabling custom frame optimization on $i"
        iw phy$phy set frag off
        ifconfig $i mtu 1500

        if [[ "$wifi_retry_short" != "" ]]; then
            iw phy$phy set retry short "$wifi_retry_short"
        fi

        if [[ "$wifi_distance" != "" ]]; then
            iw phy$phy set distance "$wifi_distance"
        fi

        if [[ "$wifi_dynack" == "true" ]]; then
            iw phy$phy set distance auto
        fi

    done

}

# Enable Digital Predistortion
paprd_on(){

    checksu || crit_error "You must be root to toggle this."

    if [[ $@ == "" ]]; then
        wifi_ap_interfaces="$(get_wifi_iface_list)"
    else
        wifi_ap_interfaces="$@"
    fi

    for i in $wifi_ap_interfaces; do
        load_prefs_iface $i
        getphy $i

        echo "Enabling digital predistortion on $i"
        echo 1 > /sys/kernel/debug/ieee80211/phy$phy/ath9k/paprd 2>/dev/null || error "Failed to set parameter"
    done

}

# Disable Digital Predistortion
paprd_off(){

    checksu || crit_error "You must be root to toggle this."

    if [[ $@ == "" ]]; then
        wifi_ap_interfaces="$(get_wifi_iface_list)"
    else
        wifi_ap_interfaces="$@"
    fi

    for i in $wifi_ap_interfaces; do
        load_prefs_iface $i
        getphy $i

        echo "Disabling digital predistortion on $i"
        echo 0 > /sys/kernel/debug/ieee80211/phy$phy/ath9k/paprd 2>/dev/null || error "Failed to set parameter"
    done

}

# Enable LNA mixing
lnamix_on(){

    checksu || crit_error "You must be root to toggle this."

    if [[ $@ == "" ]]; then
        wifi_ap_interfaces="$(get_wifi_iface_list)"
    else
        wifi_ap_interfaces="$@"
    fi

    for i in $wifi_ap_interfaces; do
        load_prefs_iface $i
        getphy $i

        echo "Enabling amplifier mixing on $i"
        echo 1 > /sys/kernel/debug/ieee80211/phy$phy/ath9k/antenna_diversity 2>/dev/null || error "Failed to set parameter"
    done

}

# Disable LNA mixing
lnamix_off(){

    checksu || crit_error "You must be root to toggle this."

    if [[ $@ == "" ]]; then
        wifi_ap_interfaces="$(get_wifi_iface_list)"
    else
        wifi_ap_interfaces="$@"
    fi

    for i in $wifi_ap_interfaces; do
        load_prefs_iface $i
        getphy $i

        echo "Disabling amplifier mixing on $i"
        echo 0 > /sys/kernel/debug/ieee80211/phy$phy/ath9k/antenna_diversity 2>/dev/null || error "Failed to set parameter"
    done

}

# Enable ACK timeout estimation algorithm
dynack_on(){

    checksu || crit_error "You must be root to toggle this."

    if [[ $@ == "" ]]; then
        wifi_ap_interfaces="$(get_wifi_iface_list)"
    else
        wifi_ap_interfaces="$@"
    fi

    for i in $wifi_ap_interfaces; do
        load_prefs_iface $i
        getphy $i
        echo "Enabling ack timeout estimation on $i"
        iw phy$phy set distance auto || error "Failed to set parameter"
    done

}

# Disable ACK timeout estimation algorithm
dynack_off(){

    checksu || crit_error "You must be root to toggle this."

    if [[ $@ == "" ]]; then
        wifi_ap_interfaces="$(get_wifi_iface_list)"
    else
        wifi_ap_interfaces="$@"
    fi

    for i in $wifi_ap_interfaces; do
        load_prefs_iface $i
        getphy $i
        echo "Disabling ack timout estimation on $i"
        iw phy$phy set distance 100 >/dev/null 2>&1 || error "Failed to set parameter"
    done

}

# Enable power management
powersave_on(){

    checksu || crit_error "You must be root to toggle this."

    if [[ $@ == "" ]]; then
        wifi_ap_interfaces="$(get_wifi_iface_list)"
    else
        wifi_ap_interfaces="$@"
    fi

    for i in $wifi_ap_interfaces; do
        load_prefs_iface $i
        echo "Enabling powersave on $i"
        iw dev $i set power_save on >/dev/null 2>&1 || error "Failed to set parameter"
    done

}

# Disable power management
powersave_off(){

    checksu || crit_error "You must be root to toggle this."

    if [[ $@ == "" ]]; then
        wifi_ap_interfaces="$(get_wifi_iface_list)"
    else
        wifi_ap_interfaces="$@"
    fi

    for i in $wifi_ap_interfaces; do
        load_prefs_iface $i
        echo "Disabling powersave on $i"
        iw dev $i set power_save off >/dev/null 2>&1 || error "Failed to set parameter"
    done

}

# Disable custom SQM
sqm_disable(){

    checksu || crit_error "You must be root to use SQM."

    local ifaces=$(ifconfig | grep -i 'flags=' | grep -v 'lo' | grep -v 'loopback' |  sed 's/:.*//')

    for i in $ifaces; do
        tc qdisc del dev $i root 2>/dev/null
        tc qdisc del dev $i handle ffff: ingress 2>/dev/null
        # FQ-CoDel is a safe alternative
        # if this fails system default (probably none) will stay
        tc qdisc add dev $i root fq_codel 2>/dev/null
    done

    # Print qdiscs in use.
    ifv tc qdisc
}

chk_qdisc(){

    [[ $(tc qdisc show dev "$1" root | grep -ic "cake") -gt 0 ]] && return 0
    return 1

}

# Enable custom SQM for bufferbloat
sqm_enable(){

    checksu || crit_error "You must be root to use SQM."

    # Group interfaces into categories
    local new_ifaces=$(ifconfig | grep -i 'flags=' | grep -v 'lo' | grep -v 'loopback' |  sed 's/:.*//')
    local ifaces=""
    NEWLINE=$'\n'

    for i in $new_ifaces; do
        chk_qdisc $i || ifaces="${ifaces}$NEWLINE${i}"
    done

    local ethernet_ifaces=$(echo -e "$ifaces" | grep -E 'enp|ens|eth')
    local wifi_ifaces=$(echo -e "$ifaces" | grep -E 'wlp|wifi|wlan')
    local vir_ifaces=$(echo -e "$ifaces" | grep -E 'vnet|team|vlan|br|virt')
    local tun_ifaces=$(echo -e "$ifaces" | grep -E 'wg|tun')
    local ppp_ifaces=$(echo -e "$ifaces" | grep -E 'ppp' | grep -v 'ifb')
    local ifb_ifaces=$(echo -e "$ifaces" | grep -E 'ppp' | grep -i 'ifb')
    local cake_chk=$(lsmod | grep -i act_mirred)

    # Insert modules for CAKE if not yet inserted
    if [[ "$cake_chk" = "" ]]; then
        modprobe sch_cake
        modprobe act_mirred
    fi

    if [[ "$enable_cake_ack_filter" == "true" ]]; then
        local extra_arg="ack-filter"
    else
        local extra_arg=""
    fi

    if [[ "$enable_cake_ack_filter" == "true" ]] && [[ "$sqm_ack_filter_aggressive" == "true" ]]; then
        local extra_arg="ack-filter-aggressive"
    fi

    if [[ $sqm_diffserv -eq 0 ]]; then

        diffserv="besteffort "

    elif [[ $sqm_diffserv -gt 0 ]]; then
        diffserv="diffserv${sqm_diffserv} "

    else
        diffserv="diffserv4 "

    fi

    # Apply qdisc in categories
    for i in $ppp_ifaces; do
        ifnq echo "Applying queue discipline to $i (ethernet interface)"

        restore_extra_arg=${extra_arg}

        if [[ $ack_filter_no_ppp == "true" ]]; then
            extra_arg=""
        fi

        ifb_check=$(tc qdisc | grep "ingress" | grep "$i");

        if [[ "$ifb_check" = "" ]]; then

            tc qdisc del dev $i root 2>/dev/null

            if [[ "$sqm_inet_upload" != "" ]]; then
                tc qdisc add dev $i root cake ${diffserv}nat ${overhead}bandwidth "$sqm_inet_upload"mbit $extra_arg
                ifnq echo "Applying queue discipline to $i (ppp interface)"
            else
                tc qdisc add dev $i root cake ${diffserv}nat ${overhead}$extra_arg
                ifnq echo "Applying queue discipline to $i (ppp interface)"
            fi

            ip link add name ifb$i type ifb 2>/dev/null
            tc qdisc del dev $i ingress 2>/dev/null
            tc qdisc add dev $i handle ffff: ingress 2>/dev/null
            tc qdisc del dev ifb$i root 2>/dev/null

            if [[ "$sqm_use_overheads" == "true" ]]; then
                overhead="overhead 35 "
            else
                overhead=""
            fi

            if [[ "$sqm_wash_markings" == "true" ]]; then
                wash="wash"
            else
                wash=""
            fi

            if [[ "$sqm_inet_download" != "" ]]; then
                tc qdisc add dev ifb$i root cake ${diffserv}nat $wash bandwidth "$sqm_inet_download"mbit ${overhead}split-gso $extra_arg
                ifnq echo "Applying queue discipline to ifb$i (ifb interface)"
            else
                tc qdisc add dev ifb$i root cake ${diffserv}nat $wash ${overhead}split-gso $extra_arg
                ifnq echo "Applying queue discipline to ifb$i (ifb interface)"
            fi

            ip link set ifb$i up
            tc filter add dev $i parent ffff: protocol all prio 10 u32 match u32 0 0 flowid 1:1 action mirred egress redirect dev ifb$i

        fi

        extra_arg=${restore_extra_arg}

    done

    if [[ "$sqm_use_overheads" == "true" ]]; then
        overhead="overhead 27 "
    else
        overhead=""
    fi

    for i in $ethernet_ifaces; do

        if ! chk_qdisc $i ; then

            if [[ "$sqm_enable_ifb_on_ethernet" == "true" ]]; then

                restore_extra_arg=${extra_arg}

                ifb_check=$(tc qdisc | grep "ingress" | grep "$i");

                if [[ "$ifb_check" = "" ]]; then

                    tc qdisc del dev $i root 2>/dev/null

                    if [[ "$sqm_inet_upload" != "" ]]; then
                        tc qdisc add dev $i root cake ${diffserv}nat ${overhead}bandwidth "$sqm_inet_upload"mbit $extra_arg
                        ifnq echo "Applying queue discipline to $i (ethernet interface)"
                    else
                        tc qdisc add dev $i root cake ${diffserv}nat ${overhead}$extra_arg
                        ifnq echo "Applying queue discipline to $i (ethernet interface)"
                    fi

                    ip link add name ifb$i type ifb 2>/dev/null
                    tc qdisc del dev $i ingress 2>/dev/null
                    tc qdisc add dev $i handle ffff: ingress 2>/dev/null
                    tc qdisc del dev ifb$i root 2>/dev/null

                    if [[ "$sqm_wash_markings" == "true" ]]; then
                        wash="wash"
                    else
                        wash=""
                    fi

                    if [[ "$sqm_inet_download" != "" ]]; then
                        tc qdisc add dev ifb$i root cake ${diffserv}nat $wash bandwidth "$sqm_inet_download"mbit ${overhead}split-gso $extra_arg
                        ifnq echo "Applying queue discipline to ifb$i (ifb interface)"
                    else
                        tc qdisc add dev ifb$i root cake ${diffserv}nat $wash ${overhead}split-gso $extra_arg
                        ifnq echo "Applying queue discipline to ifb$i (ifb interface)"
                    fi

                    ip link set ifb$i up
                    tc filter add dev $i parent ffff: protocol all prio 10 u32 match u32 0 0 flowid 1:1 action mirred egress redirect dev ifb$i

                fi

                extra_arg=${restore_extra_arg}

            else
                ifnq echo "Applying queue discipline to $i (ethernet interface)"
                tc qdisc del dev $i root 2>/dev/null
                tc qdisc add dev $i root cake ${diffserv}nat ${overhead}split-gso $extra_arg

            fi
        fi
    done

    if [[ "$sqm_use_overheads" == "true" ]]; then
        overhead=""
    else
        overhead=""
    fi

    for i in $wifi_ifaces; do

        if ! chk_qdisc $i ; then

            ifnq echo "Applying queue discipline to $i (wireless interface)"
            tc qdisc del dev $i root 2>/dev/null
            if [[ "$sqm_wifi_wash" == "true" ]]; then
                tc qdisc add dev $i root cake wash besteffort ${overhead}split-gso nat rtt 150ms $extra_arg
            else
                tc qdisc add dev $i root cake ${diffserv}${overhead}split-gso nat rtt 150ms $extra_arg
            fi
        fi

    done

    if [[ "$sqm_use_overheads" == "true" ]]; then
        # Assume virtual interfaces don't have overhead
        overhead=""
    else
        overhead=""
    fi

    for i in $vir_ifaces; do

        if ! chk_qdisc $i ; then

            ifnq echo "Applying queue discipline to $i (virtual interface)"
            tc qdisc del dev $i root 2>/dev/null
            tc qdisc add dev $i root cake ${diffserv}${overhead}split-gso nat rtt 10ms $extra_arg

        fi

    done

    if [[ "$sqm_use_overheads" == "true" ]]; then
        overhead="conservative "
    else
        overhead=""
    fi

    for i in $tun_ifaces; do

        if ! chk_qdisc $i ; then

            ifnq echo "Applying queue discipline to $i (tunnel interface)"
            tc qdisc del dev $i root 2>/dev/null
            tc qdisc add dev $i root cake ${diffserv}${overhead}split-gso nat rtt 300ms $extra_arg

        fi

    done

    for i in $ifaces; do

        if ! chk_qdisc $i; then
            ifnq echo "Applying queue discipline to $i (generic interface)"
            tc qdisc del dev $i root
            tc qdisc add dev $i root cake nat split-gso
        fi

    done

    # Show qdisc info if verbose
    ifv tc qdisc
    ledctl blink

    # Enable rpfilter
    if [[ "$enable_rpfilter" == "true" ]]; then
        for i in /proc/sys/net/ipv4/conf/*/rp_filter; do
            echo 2 | tee $i &>/dev/null
        done
    fi

    # Enable BBR or BBRv2
    if [[ "$enable_bbr" == "true" ]]; then

        if [[ $(sysctl net.ipv4.tcp_congestion_control | grep -i bbr | wc -l) -eq 0 ]]; then

            modprobe tcp_bbr 2>/dev/null
            modprobe tcp_bbr2 2>/dev/null

            if [[ "$(sysctl net.ipv4.tcp_allowed_congestion_control | grep -iF bbr2 | wc -l)" -gt 0 ]]; then
                ifnq echo "Enabling BBRv2 congestion control"
                sysctl net.ipv4.tcp_congestion_control=bbr2
                return 0
            elif [[ "$(sysctl net.ipv4.tcp_allowed_congestion_control | grep -iF bbr | wc -l)" -gt 0 ]]; then
                ifnq echo "Enabling BBRv1 congestion control"
                sysctl net.ipv4.tcp_congestion_control=bbr
                return 0
            else
                ifv echo "Your kernel does not support either BBRv1 or BBRv2, or the modules aren't loaded. Keeping default congestion control."
            fi
        fi
    else
        if [[ $(sysctl net.ipv4.tcp_congestion_control | grep -i bbr | wc -l) -gt 0 ]]; then
            sysctl net.ipv4.tcp_congestion_control=cubic
        fi
    fi


}

# ANI and PAPRD recalibration
ath9k_recalibrate(){

    checksu || crit_error "You must be root to do this."

    if [[ $@ == "" ]]; then
        wifi_ap_interfaces="$(get_wifi_iface_list)"
    else
        wifi_ap_interfaces="$@"
    fi

    for i in $wifi_ap_interfaces; do
        load_prefs_iface $i
        ledctl periodic
        ledctl mklock 3
        ifnq echo "Recalibrating special ath9k features on $i:"

        if [[ "$wifi_ani" == "true" ]]; then
            ani_off $i
            sleep 3
            ani_on $i
            ifnq echo "Adaptive noise immunity recalibration: done"
        fi

        ledctl rmlock 3
        ledctl blink
    done

}

# Critical error on bad options file
load_prefs_error(){

    if [[ -f /etc/routertools.d/x86routertools.conf ]]; then
        crit_error "Syntax error on /etc/routertools.d/x86routertools.conf, cannot continue."
    else
        echo "Looks like you have no system configuration files for x86routertools. (/etc/routertools.d/)"
        echo "I'm going to generate them now."
        rm -r /etc/routertools.d &>/dev/null
        initfs
    fi

}

load_prefs_daemon_error(){

    if [[ -f /etc/routertools.d/daemon.conf ]]; then
        crit_error "Syntax error on /etc/routertools.d/daemon.conf, cannot continue."
    else
        echo "Generating new daemon.conf in /etc/routertools.d/ ..."
        initfs_daemon_cfg
    fi

}

# Load contents of routertools options files
load_prefs(){

    set -a
    source /etc/routertools.d/x86routertools.conf || load_prefs_error
    source /etc/routertools.d/daemon.conf || load_prefs_daemon_error

}

# Load contents of wifi options files
load_prefs_iface(){

    local i=$1
    set -a
    source /etc/routertools.d/wifi-access-points/$i.conf || error "Syntax error on interface configuration file"

}

# Get list of registered wifi profiles
get_wifi_iface_list(){

    ls /etc/routertools.d/wifi-access-points | grep -i ".conf" | grep -v "_hostapd" | grep -v "example_" | cut -f 1 -d '.'
    local iface_count=$(ls /etc/routertools.d/wifi-access-points | grep -i ".conf" | grep -v "_hostapd" | grep -v "example_" | wc -l)

    if [[ $iface_count -lt 1 ]]; then
        error "No wireless interfaces configured in /etc/routertools.d/wifi-access-points, please refer to the examples included and edit them."
        return 1
    else
        return 0
    fi

}

# Stop hostapd and PHY
ap_stop(){

    if [[ $@ == "" ]]; then
        wifi_ap_interfaces="$(get_wifi_iface_list)"
    else
        wifi_ap_interfaces="$@"
    fi

    checksu || crit_error "You must be root to execute this function."

    for i in $wifi_ap_interfaces; do
        echo "Stopping wifi access point on interface $i"
        check_iface_exists $i
        load_prefs_iface $i

        kill $(cat /dev/shm/hostapd_pid_$i) 2>/dev/null || killall hostapd 2>/dev/null
        rm /dev/shm/hostapd_pid_$i 2>/dev/null
        ifconfig $i down 2>/dev/null

        if [[ -f /etc/routertools.d/scripts/stop-$i ]]; then
            echo "Running custom stop script for interface $i"
            source /etc/routertools.d/scripts/stop-$i
        fi
    done
}

# Start hostapd and PHY, set everything up
ap_start(){

    if [[ $@ == "" ]]; then
        wifi_ap_interfaces="$(get_wifi_iface_list)"
    else
        wifi_ap_interfaces="$@"
    fi

    checksu || crit_error "You must be root to execute this function."

    for i in $wifi_ap_interfaces; do

        echo "Starting wifi access point on interface $i"

        check_iface_exists $i
        load_prefs_iface $i

        if [[ "$require_internet" == "true" ]] && [[ $IS_DAEMON -ne 1 ]]; then
            echo "Internet requirement is enabled, checking connectivity"

            if check_inet_short; then
                echo "Internet is reachable, continuing"
            else
                echo "Internet is not reachable, exiting"
                _exit
            fi

        fi

        # Most drivers never update their regdomain at runtime, so we must set it first.
        # Check to see if this is a two letter code
        if [[ "$wifi_regdomain" != "" ]] && [[ $(echo "$wifi_regdomain" | fold -w1 | wc -l) -eq 2 ]]; then
            ifv echo "setting regulatory domain to $wifi_regdomain"
            iw reg set $wifi_regdomain
        elif [[ "$wifi_regdomain" != "" ]] && [[ $(echo "$wifi_regdomain" | fold -w1 | wc -l) -ne 2 ]]; then
            crit_error "$wifi_regdomain is not a valid regulatory domain! It must be a two letter country code."
        fi

        for driver in $wifi_drivers; do

            if [[ "$wifi_reload_drivers" == "true" ]]; then
                modprobe -r $driver
            fi

            modprobe $driver

        done

        getphy $i
        check_can_be_ap $i
        check_services_exist
        ap_stop 2>&1 >/dev/null

        if [[ "$wifi_powersave" == "true" ]]; then
            powersave_on $i
        elif [[ "$wifi_powersave" == "false" ]]; then
            powersave_off $i 2>/dev/null
        fi

        getphy $i || crit_error "Couldn't get a phy number for interface $i even after trying twice, this usually means your network card isn't initialized by the driver yet."

        # Execute hostapd
        rm /var/log/hostapd_$i.log
        hostapd /etc/routertools.d/wifi-access-points/${i}_hostapd.conf > /var/log/hostapd_$i.log &
        hostapd_pid=$!

        echo "$hostapd_pid" > /dev/shm/hostapd_pid_$i

        chmod og+r /dev/shm/hostapd_pid_$i

        ifv echo "storing hostapd pid in /dev/shm/hostapd_pid_$i"
        ifv echo "hostapd pid for $i -> $hostapd_pid"

        if [[ "$hostapd_wait_for_secs" == "auto" ]]; then
            # timeouts in a minute
            half_seconds=0

            while [[ $half_seconds -lt 120 ]]; do

                check_done=$(cat /var/log/hostapd_$i.log | grep -c "AP-ENABLED")

                if [[ $check_done -gt 0 ]]; then
                    echo "hostapd is ready, waited $((half_seconds / 2)) seconds."
                    break
                fi

                sleep 0.5
                half_seconds=$((half_seconds + 1))
            done

        else
            echo "Waiting $hostapd_wait_for_secs seconds for hostapd to be ready (noauto)."
            sleep $hostapd_wait_for_secs
        fi

        setup_ap_networking $i || error "An error occourred trying to set up AP networking."
        setup_ap_helpers $i

        if [[ "$wifi_disable_cck" == "true" ]]; then
            disable_cck_rates $i
        fi

        if [[ $wifi_retry_short -gt 0 ]] && [[ $wifi_retry_long -gt 0 ]]; then
            iw phy$phy set retry short $wifi_retry_short
            iw phy$phy set retry long $wifi_retry_long
        fi

        if [[ $wifi_coverage -gt 0 ]]; then
            iw phy$phy set coverage $wifi_coverage
        fi

        if [[ "$wifi_txpower" != "auto" ]]; then
            if [[ $wifi_txpower -gt 0 ]]; then
                iw phy$phy set txpower $wifi_txpower 2>/dev/null
            fi
        else
            iw phy$phy set txpower auto
        fi

        if [[ "$wifi_paprd" == "true" ]]; then
            paprd_on $i
        elif [[ "$wifi_paprd" == "false" ]]; then
            paprd_off $i 2>/dev/null
        fi

        if [[ "$wifi_lnamix" == "true" ]]; then
            lnamix_on $i
        elif [[ "$wifi_lnamix" == "false" ]]; then
            lnamix_off $i 2>/dev/null
        fi

        if [[ "$wifi_dynack" == "true" ]]; then
            dynack_on $i
        elif [[ "$wifi_dynack" == "false" ]]; then
            dynack_off $i 2>/dev/null
        fi

        if [[ "$wifi_powersave" == "true" ]]; then
            powersave_on $i
        elif [[ "$wifi_powersave" == "false" ]]; then
            powersave_off $i 2>/dev/null
        fi

        if [[ "$wifi_ani" == "true" ]]; then
            ani_on $i
        elif [[ "$wifi_ani" == "false" ]]; then
            ani_off $i 2>/dev/null
        fi

        if [[ $wifi_distance -gt 0 ]]; then
            iw phy$phy set distance $wifi_distance
        fi

        if [[ "$wifi_frame_optimization" == "true" ]]; then
            frame_opt_on
        fi

        if [[ "$wifi_darkstat_port" != "" ]]; then
            [[ $wifi_darkstat_port -gt 0 ]] || error "wifi_darkstat_port must be a port number > 0!"
            echo "Restarting darkstat for $i on port $wifi_darkstat_port"
            ifv echo "storing darkstat pid in /dev/shm/darkstat_pid_$i"

            [[ -f /dev/shm/darkstat_pid_$i ]] && kill $(cat /dev/shm/darkstat_pid_$i)
            rm /dev/shm/darkstat_pid_$i 2>/dev/null

            darkstat --user darkstat -i $i -p $wifi_darkstat_port 2>/dev/null &
            darkstat_pid=$?
            echo "$darkstat_pid" > /dev/shm/darkstat_pid_$i
        fi

        if [[ "$restart_services_for_wifi" == "true" ]]; then
            restart_services
        fi

        if [[ -f /etc/routertools.d/scripts/start-$i ]]; then
            echo "Running custom start script for interface $i"
            source /etc/routertools.d/scripts/start-$i
        fi

    done
    _exit

}

# Checks if PHY can be in master/AP mode
check_can_be_ap(){

    local i=$1
    getphy $i

    [[ $(iw phy$phy info | grep -E '{.* managed.* AP.*}' | wc -l) -gt 0 ]] || crit_error "This interface does not support AP and Managed modes! You may not use it."

}

# Checks if common router services are installed, optional
check_services_exist(){

    if [[ "$silence_check_services" != "true" ]]; then
        echo "Checking installed services"
        echo "You can silence these messages in the configuration file."

        dnsmasq -v 2>&1 >/dev/null || error "dnsmasq is not installed, your wifi access point may not offer its own DHCP unless dnsmasq is installed and configured."
        dhcpcd --version 2>&1 >/dev/null || error "dhcpcd is not installed, your wifi access point may not be able to use DHCP from another router."
        hostapd -v 2>&1 >/dev/null || error "hostapd is not installed, your wifi access point can not be started without it."
        haveged -V 2>&1 >/dev/null || error "haveged is not installed, your wifi access point needs entropy and might be less secure without it. Please, please don't use open networks unless you really need to."
        [[ $(networkctl 2>&1 | grep -iF "systemd-networkd is not running" | wc -l) -gt 0 ]] && error "systemd-networkd might be running. It may conflict with your wifi access point."

    fi

}

# Checks if the interface actually exists on the configuration
check_iface_exists(){

    local i=$1

    if [[ ! -f /etc/routertools.d/wifi-access-points/$i.conf ]]; then
        crit_error "This interface does not have a configuration file."
    fi

    if [[ ! -f /etc/routertools.d/wifi-access-points/"$i"_hostapd.conf ]]; then
        crit_error "This interface does not have a hostapd configuration file."
    fi

}

# Checks if the interface actually exists on the configuration (returns 1 or 0)
check_iface_exists_return(){

    local i=$1

    if [[ ! -f /etc/routertools.d/wifi-access-points/$i.conf ]]; then
        return 1
    fi

    if [[ ! -f /etc/routertools.d/wifi-access-points/"$i"_hostapd.conf ]]; then
        return 1
    fi

    return 0

}

# Checks if the interface is on the system at all
check_iface_present(){

    local i=$1

    if [[ $(ifconfig -a | grep "flags=" | cut -d" " -f1 | grep -c "$i") -ne 0 ]]; then
        return 0
    else
        return 1
    fi
}

# Checks if the specified wifi AP is up
check_ap(){

    if [[ $@ == "" ]]; then
        ifaces="$(get_wifi_iface_list)"
    else
        ifaces="$@"
    fi

    for i in $ifaces; do

        is_on=$(netstat -i | grep $i | wc -l)
        is_ap=$(iw "$i" info | grep -i type | grep -ic 'AP')
        check_iface_exists $i

        if [[ $is_on -lt 1 ]] || [[ $is_ap -lt 1 ]]; then
            echo "Interface $i is down."
            checksu || crit_error "You need to be root for this to start it back up."
            echo "Starting it now."
            ledctl periodic
            ledctl mklock 1
            ap_start $i
            ledctl rmlock 1
            ledctl blink
        else
            if get_hostapd_status $i ; then
                ifnq echo "Interface $i is up, in AP mode and its hostapd instance is running. Nothing to do."
                ifv echo "Netstat dump: $(netstat -i | grep -i wlp4s0 | tr -d [:alpha:] | tr -d [:blank:])"
                ledctl rmlock 1
                ledctl blink
            else
                echo "Interface $i is down, not in AP mode or its hostapd instance is not running."
                checksu || crit_error "You need to be root for this to start it back up."
                echo "Attempting to start $i now."
                ledctl periodic
                ledctl mklock 1
                ap_start $i
                ledctl rmlock 1
                ledctl blink
            fi
        fi

    done

}

# Sets up basic iptables and gateway for the wifi AP
setup_ap_networking(){

    local i=$1
    w=0
    z=0
    a=0
    load_prefs_iface $i
    gateways="$gateway $gateway_x"
    gateways6="$gateway_6 $gateway_6x"
    wifi_virtual_ifaces="$i $wifi_virtual_ifaces"

    for i in $wifi_virtual_ifaces; do
        w=$(( $w + 1 ))

        for gtu in $gateways; do
            gateway="$gtu"
            z=$(( $z + 1 ))
            if [[ $z -eq $w ]]; then
                z=0
                break
            fi
        done

        for gtu6 in $gateways6; do
            gateway_6="$gtu6"
            a=$(( $a + 1 ))
            if [[ $a -eq $w ]]; then
                a=0
                break
            fi
        done

        echo "Gateway for interface $i is $gateway"
        ip addr flush $i
        ip link set up dev $i
        ip addr add $gateway/24 broadcast ${gateway%.*}.255 dev $i
        iptables -w -t nat -I POSTROUTING -s ${gateway%.*}.0/24 ! -o $i -j MASQUERADE
        iptables -w -I FORWARD -i $i -s ${gateway%.*}.0/24 -j ACCEPT
        iptables -w -I FORWARD -i lo -d ${gateway%.*}.0/24 -j ACCEPT && echo "CONNECTED (v4): interface lo <-> interface $i"
        iptables -w -I FORWARD -i $inet_iface -d ${gateway%.*}.0/24 -j ACCEPT 2>/dev/null && echo "CONNECTED (v4): interface $inet_iface <-> interface $i"
        echo "IPv4 addresses on $i:"
        ip -4 addr show $i | grep inet
        echo 1 > /proc/sys/net/ipv4/conf/lo/forwarding
        echo 1 > /proc/sys/net/ipv4/ip_forward

        if [[ "$enable_ipv6" == "true" ]]; then
            echo "Enabling IPv6 forwarding on $i"
            echo 1 > /proc/sys/net/ipv6/conf/$i/forwarding
            if [[ "$regenerate_link_local" == "true" ]]; then
                echo "Regenerating IPv6 link-local addresses on all interfaces"
                sysctl net.ipv6.conf.all.addr_gen_mode=0 2>/dev/null
                sysctl net.ipv6.conf.all.addr_gen_mode=1 2>/dev/null
            else
                echo "Regenerating IPv6 link-local addresses on $i"
                sysctl net.ipv6.conf.$i.addr_gen_mode=0 2>/dev/null
                sysctl net.ipv6.conf.$i.addr_gen_mode=1 2>/dev/null
            fi
            echo "IPv6 addresses on $i:"
            ip -6 addr show $i | grep inet6
        fi

        if [[ $enable_pptp == "true" ]]; then
            echo "Enabling PPTP support"
            modprobe nf_nat_pptp > /dev/null 2>&1
        fi

    done

    if [[ "$enable_cake_sqm" == "true" ]]; then
        sqm_enable
    fi
}

# Set up additional services for entropy generation, optional
setup_ap_helpers(){

    local i=$1

    if [[ "$enable_rngd" == "true" ]]; then
        systemctl restart rngd || error "Couldn't start entropy provider `rngd` from `rng-tools`"
    fi

    systemctl restart haveged || error "Couldn't start entropy provider `haveged`. Your network will still work but may be less secure."

}

# Checks if the specified systemd service is online
get_service_status(){

    local i=$1
    systemctl --no-pager 2>&1 | grep -iF $i | grep -iF active | wc -l

}

# DNS status check function
get_dns_status(){

    local domain="$1"

    # Check if the user actually put in a number in the config.
    if [[ "$inet_check_timeout" != "" ]] && [[ $inet_check_timeout -eq $inet_check_timeout ]]; then
        ifv echo "inet_check_timeout is ${inet_check_timeout}s"
        local inet_check_timeout=$(( $inet_check_timeout * 10 )) # n * 100ms
        local inet_check_ping_timeout=$(( $inet_check_timeout / 10)) # n * 1s
    else
        # Defaults to this
        ifv echo "inet_check_timeout $inet_check_timeout is invalid, defaulting to 7s"
        local inet_check_timeout=70 # n * 100ms
        local inet_check_ping_timeout=$(( $inet_check_timeout / 10)) # n * 1 s
    fi

    if [[ "$domain" == "" ]]; then
        return 0
    fi

    rm /dev/shm/routertools.netrec.dns 2>/dev/null

    stdbuf -oL ping -c 1 -w $inet_check_ping_timeout $domain 2>&1 | stdbuf -oL grep -v PING > /dev/shm/routertools.netrec.dns &

    local ping_pid=$!
    local elapsed=0

    # Sometimes ping will get stuck. This kills ping.
    while [[ $elapsed -lt $inet_check_timeout ]]; do
        ledctl blink
        elapsed=$(( $elapsed + 1))
        [[ -f /dev/shm/routertools.netrec.dns ]] && [[ -s /dev/shm/routertools.netrec.dns ]] && break
        sleep .1
    done

    local dnscheck=$(cat /dev/shm/routertools.netrec.dns 2>/dev/null | grep -Ei "Name or service not known|temporary" | wc -l)

    if [[ $elapsed -eq $inet_check_timeout ]] && [[ ! -s /dev/shm/routertools.netrec.dns ]]; then
        local dnscheck=1
    fi

    if [[ $dnscheck -gt 0 ]]; then
        rm /dev/shm/routertools.netrec.dns 2>/dev/null
        kill $ping_pid 2>/dev/null
        return 1
    else
        ifnq echo "Domain name $domain can be resolved."
        rm /dev/shm/routertools.netrec.dns 2>/dev/null
        kill $ping_pid 2>/dev/null
        return 0
    fi

    kill $ping_pid 2>/dev/null
    rm /dev/shm/routertools.netrec.dns

}

get_hostapd_status(){

    local i=$1
    # We need to find out if hostapd is running for an interface to know
    # if it's actually "up".
    local hostapd_pid=$(cat /dev/shm/hostapd_pid_$i)

    if [[ "$hostapd_pid" = "" ]]; then
        # Hostapd has not been run this session
        return 1
    fi

    if ps -p $hostapd_pid > /dev/null; then
        # Hostapd is definitely running
        return 0
    else
        return 1
    fi

}

# Check wheter or not we can reach servers on the internet
get_inet_status(){

    # Check if the user actually put in a number in the config.
    if [[ "$inet_check_timeout" != "" ]] && [[ $inet_check_timeout -eq $inet_check_timeout ]]; then
        local inet_check_timeout=$(( $inet_check_timeout * 10 )) # n * 100ms
        local inet_check_ping_timeout=$(( $inet_check_timeout / 10)) # n * 1s
    else
        # Defaults to this
        local inet_check_timeout=70 # n * 100ms
        local inet_check_ping_timeout=$(( $inet_check_timeout / 10)) # n * 1 s
    fi

    local ip="$1"

    if [[ "$ip" == "" ]]; then
        return 0
    fi

    rm /dev/shm/routertools.netrec.inet 2>/dev/null
    stdbuf -oL ping -c 1 -w $inet_check_ping_timeout "$ip" 2>&1 | stdbuf -oL grep -v PING > /dev/shm/routertools.netrec.inet &
    local ping_pid=$!
    local elapsed=0

    # Sometimes ping will get stuck. This kills ping.
    while [[ $elapsed -lt $inet_check_timeout ]]; do
        ledctl blink
        elapsed=$(( $elapsed + 1))
        [[ -f /dev/shm/routertools.netrec.inet ]] && [[ -s /dev/shm/routertools.netrec.inet ]] && break
        sleep .1
    done

    local inetcheck=$(cat /dev/shm/routertools.netrec.inet 2>/dev/null | grep -Ei "unreachable|temporary|100% packet loss" | wc -l)

    if [[ $elapsed -eq $inet_check_timeout ]] && [[ ! -s /dev/shm/routertools.netrec.inet ]]; then
        local inetcheck=1
    fi

    if [[ $inetcheck -gt 0 ]]; then
        return 1
        rm /dev/shm/routertools.netrec.inet 2>/dev/null
        kill $ping_pid 2>/dev/null
    else
        ifnq echo "External addresses are reachable."
        rm /dev/shm/routertools.netrec.inet 2>/dev/null
        kill $ping_pid 2>/dev/null

        return 0
    fi

}

# Checks if the internet-facing interface is up
get_inet_iface_status(){

    local istatus=$(netstat -i | awk '{print $1;}' | grep -vE "Kernel|Iface" | grep -w "$inet_iface" | wc -l)
    ledctl blink

    if [[ $istatus -gt 0 ]]; then
        ifnq echo "Interface $inet_iface is up."
        return 0
    else
        echo "Interface $inet_iface is down."
        return 1
    fi

}

# Display services status
status_services(){

    for i in $important_services; do
        systemctl --no-pager 2>&1 | grep -iF $i
    done

}

# Check and display wifi AP status
status_wifi(){

    if [[ $@ == "" ]]; then
        ifaces="$(get_wifi_iface_list)"
    else
        ifaces="$@"
    fi

    for i in $ifaces; do

        infq echo "Probing AP $i status..."
        local is_on=$(netstat -i | grep -c "$i")
        local is_ap=$(iw "$i" info | grep -i type | grep -ic 'AP')
        ledctl blink

        if [[ $is_on -gt 0 ]]; then
            echo "Interface $i is up."
        else
            echo "Interface $i is down."
        fi

        if [[ $is_ap -gt 0 ]]; then
            echo "Interface $i is in AP mode."
        else
            echo "Interface $i is NOT in AP mode."
        fi

        if get_hostapd_status $i; then
            echo "Hostapd is up for interface $i."
        else
            echo "Hostapd is NOT online for interface $i."
        fi

    done

}

# Info dump on queue disciplines
info_qdisc(){

    echo "Dumping info on qdisc and SQM"
    tc qdisc

}

# Info dump on wireless AP
info_wifi(){

    if [[ $@ == "" ]]; then
        ifaces="$(get_wifi_iface_list)"
    else
        ifaces="$@"
    fi

    for i in $ifaces; do
        getphy $i
        echo "Dumping wireless info on interface $i"
        echo "# iw phy info #"
        iw phy$phy info
        echo "# iw dev info #"
        iw dev $i info
        echo "# netstat -i #"
        netstat -i
    done

}

# Info dump on internet interface
info_internet(){

    echo "Dumping info on internet interface"
    ifconfig $inet_iface

}

# Check and fix internet availability
check_internet(){

    checksu || crit_error "You must be root to do this!"
    ifnq echo "Probing internet status..."

    local bad_dns_1=0
    local bad_dns_2=0
    local bad_dns_3=0
    local bad_dns_4=0
    local reason_1=""
    local reason_2=""
    local bad_inet_iface=0
    local bad_inet=0
    local bad_inet_1=0
    local bad_inet_2=0
    local bad_dns=0

    import_addresses

    if get_inet_iface_status >/dev/null; then
        ifnq echo "Internet interface test: Online"
    else
        echo "Internet interface test: Offline"
        bad_inet_iface=1
    fi

    if get_inet_status "$addr_inet_1" >/dev/null; then
        ifnq echo "Internet availability test 1 ($addr_inet_1): Online"
    else
        echo "Internet availability test 1 ($addr_inet_1): Offline"
        bad_inet_1=1
    fi

    if get_inet_status "$addr_inet_2" >/dev/null; then
        ifnq echo "Internet availability test 2 ($addr_inet_2): Online"
    else
        echo "Internet availability test 2 ($addr_inet_2): Offline"
        bad_inet_2=1
    fi

    if get_dns_status "$addr_dns_1" >/dev/null; then
        ifnq echo "DNS availability test 1 ($addr_dns_1): Resolved"
    else
        echo "DNS availability test 1 ($addr_dns_1): Did not resolve"
        bad_dns_1=1
    fi

    if get_dns_status "$addr_dns_2" >/dev/null; then
        ifnq echo "DNS availability test 2 ($addr_dns_2): Resolved"
    else
        echo "DNS availability test 2 ($addr_dns_2): Did not resolve"
        bad_dns_2=1
    fi

    if get_dns_status "$addr_dns_3" >/dev/null; then
        ifnq echo "DNS availability test 3 ($addr_dns_3): Resolved"
    else
        echo "DNS availability test 3 ($addr_dns_3): Did not resolve"
        bad_dns_3=1
    fi

    if get_dns_status "$addr_dns_4" >/dev/null; then
        ifnq echo "DNS availability test 4 ($addr_dns_4): Resolved"
    else
        echo "DNS availability test 4 ($addr_dns_4): Did not resolve"
        bad_dns_4=1
    fi

    if [[ $bad_dns_1 -eq 1 ]] && [[ $bad_dns_2 -eq 1 ]] && [[ $bad_dns_3 -eq 1 ]] && [[ $bad_dns_4 -eq 1 ]]; then
        bad_dns=1
    fi

    if [[ $bad_inet_1 -eq 1 ]] && [[ $bad_inet_2 -eq 1 ]]; then
        bad_inet=1
    fi

    # Act on test results
    if [[ $bad_inet -eq 1 ]] || [[ $bad_inet_iface -eq 1 ]]; then
        echo "Internet is not reachable, attempting to reconnect"
        ledctl periodic
        ledctl mklock 2
        if [[ $bad_inet -eq 1 ]]; then
            echo "Reason: Could not reach external addresses"
            reason_1="could not reach external addresses"
        fi

        if [[ $bad_inet_iface -eq 1 ]]; then
            echo "Reason: Internet interface is down"
            reason_2="internet interface is down"
        fi

        if [[ "$reason_1" == "" ]] && [[ "$reason_2" != "" ]]; then
            rootnotify "Attempting to reconnect, $reason_2"
        fi

        if [[ "$reason_2" == "" ]] && [[ "$reason_1" != "" ]]; then
            rootnotify "Attempting to reconnect, reason_1"
        fi

        if [[ "$reason_1" != "" ]] && [[ "$reason_2" != "" ]]; then
            rootnotify "Attempting to reconnect, $reason_1 and $reason_2"
        fi

        stop_internet
        start_internet
    else
        ifnq echo "Internet interface is working normally"
        ledctl rmlock 2
        ledctl blink
    fi

    if [[ $bad_dns -eq 1 ]]; then
        echo "DNS is not working, attempting to restart it"
        rootnotify "Attempting to restart DNS, cannot resolve domain names"
        ledctl periodic
        ledctl mklock 2
        restart_services
    else
        ifnq echo "DNS lookup is working normally"
        sleep 0.5
        ledctl rmlock 2
        ledctl blink
    fi

}

import_addresses(){

    # Reload preferences
    load_prefs 2>/dev/null

    # Default addresses
    addr_dns_1="google-public-dns-a.google.com"
    addr_dns_2="a.root-servers.org"
    #addr_dns_3="www.tp-link.com"
    #addr_dns_4="github.com"
    addr_inet_1="1.1.1.1"
    addr_inet_2="8.8.8.8"

    [[ "${dns_check_addresses[0]}" != "" ]] && addr_dns_1="${dns_check_addresses[0]}"
    [[ "${dns_check_addresses[1]}" != "" ]] && addr_dns_2="${dns_check_addresses[1]}"
    [[ "${dns_check_addresses[2]}" != "" ]] && addr_dns_3="${dns_check_addresses[2]}"
    [[ "${dns_check_addresses[3]}" != "" ]] && addr_dns_4="${dns_check_addresses[3]}"

    [[ "${ip_check_addresses[0]}" != "" ]] && addr_inet_1="${ip_check_addresses[0]}"
    [[ "${ip_check_addresses[1]}" != "" ]] && addr_inet_2="${ip_check_addresses[1]}"

    is_int $inet_check_timeout || export inet_check_timeout="4"

}

check_inet_short(){

    local bad_dns_1=0
    local bad_dns_2=0
    local bad_dns_3=0
    local bad_dns_4=0
    local bad_inet_iface=0
    local bad_inet_1=0
    local bad_inet_2=0

    import_addresses

    if ! get_inet_iface_status >/dev/null; then
        bad_inet_iface=1
    fi

    if [[ $bad_inet_iface -eq 1 ]]; then
        return 1
    fi

    if ! get_inet_status "$addr_inet_1" >/dev/null; then
        bad_inet_1=1
    fi

    if ! get_inet_status "$addr_inet_2" >/dev/null; then
        bad_inet_2=1
    fi

    if [[ $bad_inet_1 -eq 1 ]] && [[ $bad_inet_2 -eq 1 ]]; then
        return 1
    fi

    if ! get_dns_status "$addr_dns_1" >/dev/null; then
        bad_dns_1=1
    fi

    if ! get_dns_status "$addr_dns_2" >/dev/null; then
        bad_dns_2=1
    fi

    if ! get_dns_status "$addr_dns_3" >/dev/null; then
        bad_dns_3=1
    fi

    if ! get_dns_status "$addr_dns_4" >/dev/null; then
        bad_dns_4=1
    fi

    if [[ $bad_dns_1 -eq 1 ]] && [[ $bad_dns_2 -eq 1 ]] && [[ $bad_dns_3 -eq 1 ]] && [[ $bad_dns_4 -eq 1 ]]; then
        return 1
    fi

}

# Start internet via user-made script
start_internet(){

    checksu || crit_error "You must be root to do this!"
    echo "Running start-internet script at /etc/routertools.d/scripts/start-internet"
    source /etc/routertools.d/scripts/start-internet || error "An error occourred while executing /etc/routertools.d/scripts/start-internet"
    returnv=$?
    if [[ "$regenerate_link_local" == "true" ]]; then
        echo "Regenerating IPv6 link-local addresses on all interfaces"
        sysctl net.ipv6.conf.all.addr_gen_mode=0 2>/dev/null
        sysctl net.ipv6.conf.all.addr_gen_mode=1 2>/dev/null
    fi
    return $returnv
}

# Stop internet via user-made script
stop_internet(){

    checksu || crit_error "You must be root to do this!"
    echo "Running stop-internet script at /etc/routertools.d/scripts/start-internet"
    source /etc/routertools.d/scripts/stop-internet || error "An error occourred while executing /etc/routertools.d/scripts/stop-internet"
    return $?
    echo "Done running script."

}

# Restart internet via user-made scripts
restart_internet(){

    checksu || crit_error "You must be root to do this!"
    echo "Restarting internet"
    echo "Running internet stop script"
    source /etc/routertools.d/scripts/stop-internet || error "An error occourred while executing /etc/routertools.d/scripts/stop-internet"
    echo "Running internet start script"
    source /etc/routertools.d/scripts/start-internet || error "An error occourred while executing /etc/routertools.d/scripts/start-internet"
    return $?
    echo "Done running scripts."

}

# Restart all services in important_services
restart_services(){

    checksu || crit_error "You must be root to restart services!"
    echo "Restarting important services"
    local i
    for i in $important_services; do
        echo "Restarting service $i"
        systemctl restart "$i" || error "Service $i failed to start"
    done

}

# Start all services in important_services
start_services(){

    checksu || crit_error "You must be root to start services!"
    echo "Restarting important services"

    for i in $important_services; do
        echo "Starting service $i"
        systemctl start "$i" || error "Service $i failed to start"
    done

}

# Install optimized defaults to sysctl.conf
sysctl_install(){

    checksu || crit_error "You must be root to install new default options to sysctl!"
    initfile /etc/sysctl.d/68-x86routertools.conf
    local f="/etc/sysctl.d/68-x86routertools.conf"

    echo "################# Added by x86routertools ####################" >> "$f"
    echo "net.ipv4.tcp_ecn = 1" >> "$f"
    echo "net.ipv4.tcp_mtu_probing = 1" >> "$f"
    echo "net.core.default_qdisc = fq_codel" >> "$f"
    echo "net.ipv4.tcp_dsack = 1" >> $f
    echo "net.ipv4.tcp_sack = 1" >> $f
    echo "net.ipv4.tcp_slow_start_after_idle = 1" >> $f
    echo "net.ipv4.tcp_tw_reuse = 1" >> $f
    echo "net.ipv4.tcp_fastopen = 3" >> $f
    echo "##############################################################" >> "$f"

    sysctl -p --system

    echo "Successfully installed and reloaded new sysctl configurations"

}

# Check and display internet availability
status_internet(){

    local bad=0

    import_addresses

    get_inet_iface_status || bad=1
    get_inet_status "$addr_inet_1" || bad=1
    get_dns_status "$addr_dns_1" || bad=1

    if [[ $bad -eq 1 ]]; then
        echo "Internet appears to be down."
    else
        echo "Internet is working normally."
    fi

}

# Clump together status functions
status_all(){

    if [[ $noclear != 1 ]]; then
        clear
    fi

    echo "# status_internet #"
    status_internet
    echo "# status_wifi #"
    status_wifi
    echo "# status_services #"
    status_services

}

# Clump together info functions
info_all(){

    if [[ $noclear != 1 ]]; then
        clear
    fi

    echo "# info_internet #"
    info_internet
    echo "# info_wifi #"
    info_wifi
    echo "# info_qdisc #"
    info_qdisc

}

# Clump together check functions
check_all(){

    if [[ $noclear != 1 ]]; then
        clear
    fi

    echo "# check_internet #"
    check_internet
    echo "# check_ap #"
    check_ap

}

# Restart specified wifi AP, or all APs
restart_wifi_ap(){

    echo "Restarting access point $1"
    ap_stop "$1"
    ap_start "$1"

}

restart_inet(){

    echo "Using user scripts to restart internet access"
    stop_internet
    start_internet

}

disown_all(){

    while true; do
        disown 2>/dev/null || break
    done

}

editconf(){

    if [[ "$EDITOR" == "" ]]; then
        EDITOR=nano
    fi

    if [[ "$1" == "" ]]; then
        ${EDITOR} /etc/routertools.d/x86routertools.conf
        _exit
    fi

    if [[ -f /etc/routertools.d/wifi-access-points/"$1".conf ]]; then
        ${EDITOR} /etc/routertools.d/wifi-access-points/"$1".conf
        _exit
    else
        crit_error "Access point $1 has no configuration file."
    fi

}

daemon_term(){

    # types inet wifi
    rm /dev/shm/routertools_pid_$daemon_type 2>/dev/null
    kill "$daemon_child_pid" 2>/dev/null
    kill -9 "$sleep_pid" 2>/dev/null
    ledctl rmlock 1 &>/dev/null
    ledctl rmlock 2 &>/dev/null
    ledctl rmlock 3 &>/dev/null
    ledctl off &>/dev/null
    _exit

}

daemon_inet(){

    export daemon_type="inet"

    if ps -p $(cat /dev/shm/routertools_pid_$daemon_type) > /dev/null 2>&1; then
        crit_error "There is an instance of this daemon already running."
    fi
    export current_iface="$inet_iface"
    ledctl rmlock 2 &>/dev/null
    ledctl blink &>/dev/null
    export daemon_pid=$BASHPID
    export daemon_child_pid=""
    GRACE_PERIOD=0
    export IS_DAEMON=1
    is_child=0

    echo $daemon_pid > /dev/shm/routertools_pid_$daemon_type
    chmod og+xr /dev/shm/routertools_pid_$daemon_type
    trap daemon_term SIGTERM SIGINT
    trap daemon_sighup SIGHUP

    # In case of unset variable
    if [[ $daemon_manage_inet_every -eq $daemon_manage_inet_every ]]; then
        true
    else
        daemon_manage_inet_every=30
    fi

    start_internet &
    sleep $daemon_manage_inet_every &
    sleep_pid=$!
    wait $sleep_pid 2>/dev/null
    kill -9 $sleep_pid 2>/dev/null
    [[ "$enable_cake_sqm" == "true" ]] && sqm_enable

    while true; do

        # Wait a grace period while internet is initializing so we don't make a mistake
        if ps -p $daemon_child_pid > /dev/null 2>&1; then
            if [[ $GRACE_PERIOD_BLOCK -eq 1 ]]; then
                GRACE_PERIOD=0
            else
                GRACE_PERIOD=1
            fi
        else
            GRACE_PERIOD=0
        fi

        if [[ $GRACE_PERIOD -eq 1 ]]; then
            GRACE_PERIOD=0
            GRACE_PERIOD_BLOCK=1
        else
            check_internet &
            daemon_child_pid=$!
            [[ "$enable_cake_sqm" == "true" ]] && sqm_enable
            export daemon_child_pid=$daemon_child_pid
            GRACE_PERIOD_BLOCK=0
        fi

        # Don't block signals on sleep
        sleep $daemon_manage_inet_every &
        sleep_pid=$!
        wait $sleep_pid 2>/dev/null
        kill -9 $sleep_pid 2>/dev/null

    done

}

daemon_wifi_recalibration(){

    is_child=1
    trap daemon_sighup SIGHUP

    while true; do

        sleep $daemon_ath9k_recalibrate_every
        sleep_pid=$!
        wait $sleep_pid 2>/dev/null
        kill -9 $sleep_pid 2>/dev/null

        if get_hostapd_status $current_iface; then
            ifnq echo "Automatic ath9k recalibration ($current_iface) in progress..."
            ath9k_recalibrate $current_iface
        fi

    done

}

daemon_wifi(){
    check_iface_exists "$1" || crit_error "Interface $1 is not configured in /etc/routertools.d"

    if ps -p $(cat /dev/shm/routertools_pid_$1) > /dev/null 2>&1; then
        crit_error "There is an instance of this daemon already running."
    fi

    export current_iface="$1"
    load_prefs_iface "$1"
    ledctl rmlock 1 &>/dev/null
    ledctl blink &>/dev/null
    export daemon_type="$1"
    export daemon_pid=$BASHPID
    export daemon_child_pid=""
    export child_recalib_pid=""
    export IS_DAEMON=1
    is_child=0

    echo $daemon_pid > /dev/shm/routertools_pid_$daemon_type
    chmod og+xr /dev/shm/routertools_pid_$daemon_type
    trap daemon_term SIGTERM SIGINT
    trap daemon_sighup SIGHUP

    # In case of unset variable
    if [[ $daemon_manage_wifi_every -eq $daemon_manage_wifi_every ]]; then
        true
    else
        daemon_manage_wifi_every=30
    fi

    # periodic ath9k-recalibrate
    if [[ $daemon_ath9k_recalibrate_every -gt 0 ]]; then
        if [[ $(echo "$wifi_drivers" | grep -c "ath9k") -gt 0 ]]; then
            ifnq echo "ath9k recalibration: enabled on $current_iface every $daemon_ath9k_recalibrate_every seconds"
            daemon_wifi_recalibration &
            child_recalib_pid=$!
            export child_recalib_pid=$child_recalib_pid
        fi
    fi

    while true; do

        if [[ "$require_internet" == "true" ]]; then
            if check_inet_short; then
                CLEAR=1
            else
                CLEAR=0
            fi
        else
            CLEAR=1
        fi

        if [[ $CLEAR -eq 1 ]]; then
            check_ap "$1" &
            daemon_child_pid=$!
            export daemon_child_pid=$daemon_child_pid
            [[ "$enable_cake_sqm" == "true" ]] && sqm_enable
        else
            if [[ $SECONDS -gt $daemon_wifi_wait_for_internet_timeout ]]; then
                check_ap "$1" &
                daemon_child_pid=$!
                export daemon_child_pid=$daemon_child_pid
                [[ "$enable_cake_sqm" == "true" ]] && sqm_enable
            fi
        fi

        # Don't block signals on sleep
        sleep $daemon_manage_wifi_every &
        sleep_pid=$!
        wait $sleep_pid 2>/dev/null
        kill -9 $sleep_pid 2>/dev/null

    done

}


stop_daemon(){

    daemon_type="$1"
    d_pid=$(cat /dev/shm/routertools_pid_$daemon_type)

    if ps -p $d_pid > /dev/null 2>&1; then
        kill $d_pid
        rm /dev/shm/routertools_pid_$daemon_type
        _exit Stopped daemon $daemon_type with pid $d_pid
    else
        crit_error "Daemon for $daemon_type wasn't running in the first place."
    fi

}

stop_daemon_inet(){

    stop_daemon inet

}

stop_daemon_wifi(){

    check_iface_exists $1 || crit_error "Interface $1 is not configured in /etc/routertools.d"
    stop_daemon $1

}

daemon_sighup(){
    echo "Recieved SIGHUP, reloading configuration."
    load_prefs

    if [[ "$daemon_type" != "inet" ]]; then
        load_prefs_iface "$current_iface"
        if [[ $child_recalib_pid -ne 0 ]]; then
            if [[ "$is_child" -ne 1 ]]; then
                echo "Forwarding SIGHUP to $child_recalib_pid"
                kill -SIGHUP $child_recalib_pid
            fi
        fi
    fi

    # Reapply SQM
    if [[ "$daemon_type" == "inet" ]]; then
        sqm_disable
        [[ "$enable_cake_sqm" == "true" ]] && sqm_enable
    fi
}

list_daemons(){

    echo "x86routertools processes running in background:"
    for i in $(find /dev/shm/* | grep '/dev/shm/routertools_pid_'); do


        if [[ $i != "" ]]; then
            daemon_type=$(echo $i | sed 's/\/dev\/shm\/routertools_pid_//g')
            daemon_pid=$(cat $i)
            if ps -p $daemon_pid > /dev/null 2>&1; then
                echo "$daemon_type - PID: $daemon_pid"
            else
                rm $i 2>/dev/null
            fi
        fi

    done
}

reload_all_daemons(){
    for i in $(find /dev/shm/* | grep '/dev/shm/routertools_pid_'); do

        if [[ $i != "" ]]; then
            daemon_type=$(echo $i | sed 's/\/dev\/shm\/routertools_pid_//g')
            daemon_pid=$(cat $i)
            if ps -p $daemon_pid > /dev/null 2>&1; then
                kill -SIGHUP $daemon_pid 2>/dev/null
                echo "Sent reload configuration request to daemon: $daemon_type"
                # Avoid doing everything at the exact same time
                sleep .1
            else
                rm $i 2>/dev/null
            fi
        fi

    done
}

# Display error count and exit
_exit(){

    returnvalue=$?

    # Echo back a 'reason' for the exit
    if [[ "$@" != "" ]]; then
        echo "$@"
    fi

    if [[ $(jobs | wc -l) -gt 0 ]]; then

        if [[ $disown_all_jobs -eq 1 ]]; then
            disown_all
            echo "Exiting with $error_count errors ($crit_count critical)"
            exit $returnvalue
        fi

        echo "Waiting for background jobs to finish..."
        wait
    fi

    echo "Exiting with $error_count errors ($crit_count critical)"
    exit $returnvalue

}

# Count command line options and do some processing on them
count_arg=0
final_args=""
_args=""
disown_all_jobs=0

for i in "$@"; do
    count_arg=$(($count_arg + 1))

    # Make concatenated options understandable by the case statement
    if [[ $i == -* ]] && [[ $i != --* ]]; then
        for (( f=1; f<${#i}; f++ )); do
            _args="${_args} -${i:$f:1}"
        done
    else
        _args="$_args $i"
    fi

    final_args=$(echo "$_args" | xargs)
    unset p
    unset i

done

if [[ $count_arg -eq 0 ]]; then

    echo "No command given, run 'x86routertools -h' for usage."
    Version

else
    if [[ "$@" == "-h" ]] || [[ "$@" == "--help" ]]; then
        true
    else
        load_prefs
    fi

fi

parse_cmdline(){

    for cmd_arg in "$@"; do
        case "$cmd_arg" in

                # Command line - to - function
                # -- and - options should come first
            -v|--version) Copyright
                shift ;;

            -V|--verbose) verbose=1
                shift ;;

            -F|--nofail) nofail=1
                shift ;;

            -q|--quiet) quiet=1
                shift ;;

            -C|--no-clear) noclear=1
                shift ;;

            -Z|--disown) disown_all_jobs=1
                shift ;;

            -D|--detach) no_service=1
                shift ;;

            --daemon) checksu || crit_error "You must be root to do this!"

                if [[ $RT_DAEMONIZE -ne 1 ]]; then
                    if [[ $no_service -eq 1 ]]; then
                        # Always use logger here
                        echo "Running with -D. Process will detach from parent and logger will be used unconditionally."
                        export RT_DAEMONIZE=1

                        $0 --daemon $2 >/dev/null & disown
                        _exit Dispatched daemon process.
                    else
                        if [[ "$use_logger" == "true" ]]; then
                            exec 1> >(logger -s -t $(basename $0)) 2>&1
                        fi
                        echo "Running without -D. Process will not detach from parent (systemd mode)."
                        daemon_wifi $2
                    fi
                else
                    exec 1> >(logger -s -t $(basename $0)) 2>&1
                    daemon_wifi $2
                fi

                shift ;;


            --daemon-list|daemon-list|list-daemons|--list-daemons) list_daemons
                shift ;;

            --daemon-stop-inet) checksu || crit_error "You must be root to do this!"
                stop_daemon_inet
                shift ;;

            --daemon-stop|--stop-daemon) checksu || crit_error "You must be root to do this!"
                stop_daemon_wifi "$2"
                shift ;;

            --daemon-reload) checksu || crit_error "You must be root to do this!"
                reload_all_daemons
                shift ;;

            --daemon-inet) checksu || crit_error "You must be root to do this!"

                if [[ $RT_DAEMONIZE -ne 1 ]]; then
                    if [[ $no_service -eq 1 ]]; then
                        # Always use logger here
                        echo "Running with -D. Process will detach from parent and logger will be used unconditionally."
                        export RT_DAEMONIZE=1

                        $0 --daemon-inet $2 >/dev/null & disown
                        _exit Dispatched daemon process.
                    else
                        if [[ "$use_logger" == "true" ]]; then
                            exec 1> >(logger -s -t $(basename $0)) 2>&1
                        fi
                        echo "Running without -D. Process will not detach from parent (systemd mode)."
                        daemon_inet $2
                    fi
                else
                    exec 1> >(logger -s -t $(basename $0)) 2>&1
                    daemon_inet $2
                fi

                shift ;;


                # Don't use fancy exit here
            --help|-h) Help
                exit 0 ;;

            info|i) info_all
                shift ;;

            status|s) status_all
                shift ;;

            check|c) check_all
                shift ;;

            list-aps|ap-list|la|accesspoints) get_wifi_iface_list
                shift ;;

            status-internet|inet|status-inet) status_internet
                shift ;;

            status-wifi|wifi) status_wifi "$2"
                shift ;;

            status-services|srv) status_services
                shift ;;

            start-internet|start-inet) start_internet
                shift ;;

            start-services) start_services
                shift ;;

            start-wifi) ap_start "$2"
                _exit ;;

            stop-internet|stop-inet) stop_internet
                shift ;;

            stop-wifi) ap_stop "$2"
                _exit ;;

            restart-services) restart_services
                shift ;;

            restart-wifi) restart_wifi_ap "$2"
                shift ;;

            restart-internet|restart-inet) restart-internet
                shift ;;

            info-internet|iinet|info-inet) info_internet
                shift ;;

            info-wifi|iwifi) info_wifi "$2"
                shift ;;

            info-qdisc|iqdisc) info_qdisc
                shift ;;

            check-internet|cinet|check-inet) check_internet
                shift ;;

            check-wifi|cwifi|cap|check-ap) check_ap "$2"
                shift ;;

            qdisc-on|sqm-enable|enable-sqm|qdisc) sqm_enable
                shift ;;

            qdisc-off|sqm-disable|disable-sqm) sqm_disable
                shift ;;

            paprd-on) paprd_on "$2"
                shift ;;

            paprd-off) paprd_off "$2"
                shift ;;

            ani-on) ani_on "$2"
                shift ;;

            ani-off) ani_off "$2"
                shift ;;

            dynack-on) dynack_on "$2"
                shift ;;

            dynack-off) dynack_off "$2"
                shift ;;

            lnamix-on) lnamix_on "$2"
                shift ;;

            lnamix-off) lnamix_off "$2"
                shift ;;

            frame-opt-on) frame_opt_on "$2"
                shift ;;

            frame-opt-off) frame_opt_off "$2"
                shift ;;

            calib|ath9k-recalibrate) ath9k_recalibrate "$2"
                shift ;;

            sysctl-install) sysctl_install
                shift ;;

            reset-config|reset-cfg) resetcfg
                shift ;;

            powersave-on) powersave_on "$2"
                shift ;;

            powersave-off) powersave_off "$2"
                shift ;;

            display-ani|show-ani) display_ani "$2"
                _exit ;;

            display-rates|show-rates) display_rates "$2" "$3"
                _exit ;;

            display-stats|show-stats) display_stats "$2" "$3"
                _exit ;;

            capabilities|show-capab) show_capabilities "$2" "$3"
                _exit ;;

            display-airtime|show-airtime) display_airtime "$2" "$3"
                _exit ;;

            display-devices|display-local-network|show-devices) display_local_network
                _exit ;;

            display-qdisc|show-qdisc) display_qdisc "$2"
                _exit ;;

            display-queries) display_queries
                _exit ;;

            display-interfaces) display_interfaces
                _exit ;;

            addresses) show_addresses "$2"
                shift ;;

            all-addresses) show_all_addresses "$2"
                shift ;;

            all-addresses6) show_all_addresses_6 "$2"
                shift ;;

            interfaces) show_interfaces
                shift ;;

            ports) show_ports
                shift ;;

            routes|route) show_routes "$2"
                shift ;;

            routes6|route6) show_routes_6 "$2"
                shift ;;

            try-resolve) quiet=1 try_resolve "$2"
                exit $? ;;

            try-reach) quiet=1 try_reach "$2"
                exit $? ;;

            list-devices|ls|show-local-network) show_local_network
                shift ;;

            list-devices6|ls6|show-local-network6) show_local_network_6
                shift ;;

            test-notify) rootnotify "$2"
                shift ;;

            edit-config|edit|conf) editconf "$2"
                shift ;;

            genconfig_all) genconfig
                shift ;;

            *) Invalid_Help
                exit 1 ;;

        esac
    done

}

# Execute commands
parse_cmdline ${final_args}

# Handle return value and errors
if [[ $count_arg -ne 0 ]]; then
    _exit
fi
